# 個人キュレーションサイト 実装計画書

## 概要
この実装計画書では、個人キュレーションサイトの開発を効率的に進めるため、作業を小さな段階に分割し、各段階で明確な成果物を定義します。

## 実装フェーズ全体像

```
Phase 1: 基盤構築（5日間）
├── Stage 1-1: プロジェクト初期設定（1日）
├── Stage 1-2: データベース構築（1日）
├── Stage 1-3: 基本API実装（1日）
├── Stage 1-4: フロントエンド基盤（1日）
└── Stage 1-5: 基本CRUD実装（1日）

Phase 2: 外部連携（4日間）
├── Stage 2-1: 外部API統合準備（1日）
├── Stage 2-2: 情報収集サービス実装（1日）
├── Stage 2-3: AI統合基盤（1日）
└── Stage 2-4: 記事生成パイプライン（1日）

Phase 3: 自動化実装（3日間）
├── Stage 3-1: Cron Job設定（1日）
├── Stage 3-2: 通知機能実装（1日）
└── Stage 3-3: エラーハンドリング強化（1日）

Phase 4: 最適化・公開（2日間）
├── Stage 4-1: パフォーマンス最適化（1日）
└── Stage 4-2: デプロイ・動作確認（1日）
```

---

## Phase 1: 基盤構築（5日間）

### Stage 1-1: プロジェクト初期設定（1日目）

**目標**: 開発環境を整備し、基本的なプロジェクト構造を確立

**作業内容**:
1. 依存パッケージのインストールと設定
   - Prisma, Zod, date-fns, axios等の追加
   - TypeScript設定の最適化
   - ESLint/Prettier設定

2. 環境変数の設定
   - `.env.local`ファイルの作成
   - 環境変数の型定義

3. 基本的なディレクトリ構造の作成
   - `src/lib`, `src/components`, `src/hooks`等の作成
   - 基本的な型定義ファイルの配置

**成果物**:
- 設定済みのプロジェクト環境
- 型安全な環境変数アクセス
- 整理されたディレクトリ構造

**検証方法**:
```bash
npm run dev  # 開発サーバーが正常に起動
npm run lint # Lintエラーがない
npm run build # ビルドが成功
```

---

### Stage 1-2: データベース構築（2日目）

**目標**: Prismaを使用したデータベース環境の構築

**作業内容**:
1. Prismaスキーマの実装
   - 全テーブルの定義
   - リレーションシップの設定
   - インデックスの定義

2. データベース接続設定
   - Vercel Postgres（またはローカルPostgreSQL）の設定
   - Prismaクライアントの設定

3. 初期マイグレーションとシードデータ
   - マイグレーションの実行
   - 開発用シードデータの作成

**成果物**:
- 完成したデータベーススキーマ
- 動作するPrismaクライアント
- 基本的なシードデータ

**検証方法**:
```bash
npx prisma migrate dev # マイグレーション成功
npx prisma db seed    # シードデータ投入成功
npx prisma studio     # データベース内容確認
```

---

### Stage 1-3: 基本API実装（3日目）

**目標**: 記事とカテゴリの基本的なAPIエンドポイント実装

**作業内容**:
1. APIルートの基本設定
   - エラーハンドリングユーティリティ
   - レスポンスフォーマット統一

2. 記事API実装
   - GET /api/articles（一覧）
   - GET /api/articles/[id]（詳細）

3. カテゴリ・タグAPI実装
   - GET /api/categories
   - GET /api/tags

**成果物**:
- 動作する基本的なAPIエンドポイント
- 統一されたエラーハンドリング
- APIレスポンスの型定義

**検証方法**:
```bash
# APIエンドポイントのテスト
curl http://localhost:3000/api/articles
curl http://localhost:3000/api/categories
```

---

### Stage 1-4: フロントエンド基盤（4日目）

**目標**: 基本的なUIコンポーネントとレイアウトの実装

**作業内容**:
1. 共通UIコンポーネント作成
   - Button, Card, Badge等の基本コンポーネント
   - Tailwind CSSを使用したスタイリング

2. レイアウトコンポーネント実装
   - Header, Footer, Navigation
   - レスポンシブ対応

3. 記事表示コンポーネント
   - ArticleCard
   - ArticleList
   - CategoryBadge

**成果物**:
- 再利用可能なUIコンポーネントライブラリ
- 統一感のあるデザインシステム
- レスポンシブ対応のレイアウト

**検証方法**:
- Storybookまたは実際のページでコンポーネント表示確認
- モバイル・デスクトップ両方でのレイアウト確認

---

### Stage 1-5: 基本CRUD実装（5日目）

**目標**: 記事の表示機能を完成させる

**作業内容**:
1. 記事一覧ページ実装
   - ページネーション
   - カテゴリフィルター

2. 記事詳細ページ実装
   - 記事内容表示
   - 関連記事表示

3. ホームページ実装
   - 最新記事表示
   - カテゴリ別セクション

**成果物**:
- 完全に動作する記事閲覧システム
- SEO対応のメタデータ
- 基本的なナビゲーション

**検証方法**:
- 記事一覧→詳細への遷移確認
- ページネーション動作確認
- SEOメタデータの確認

---

## Phase 2: 外部連携（4日間）

### Stage 2-1: 外部API統合準備（6日目）

**目標**: 外部APIとの接続基盤を整備

**作業内容**:
1. APIクライアントの基本実装
   - HTTPクライアント設定
   - レート制限管理基盤
   - APIキー管理

2. 外部API認証設定
   - 各APIのキー取得・設定
   - 環境変数への追加

3. モックデータ作成
   - 開発用のモックレスポンス
   - テスト用データ

**成果物**:
- 設定済みのAPIクライアント
- レート制限管理システム
- 開発用モックデータ

---

### Stage 2-2: 情報収集サービス実装（7日目）

**目標**: 各情報源からのデータ収集機能実装

**作業内容**:
1. 収集サービス基底クラス実装
   - 共通インターフェース定義
   - エラーハンドリング

2. 個別収集サービス実装（優先順位順）
   - RSSパーサー（最も簡単）
   - News API
   - Reddit API

3. 収集マネージャー実装
   - 複数ソースの統合
   - 重複除去

**成果物**:
- 動作する情報収集システム
- 少なくとも2つの情報源からのデータ取得
- 統合されたデータフォーマット

---

### Stage 2-3: AI統合基盤（8日目）

**目標**: OpenAI APIとの統合基盤構築

**作業内容**:
1. AI クライアント実装
   - OpenAI SDK設定
   - プロンプト管理システム

2. 基本的なAI機能実装
   - 簡単な要約生成
   - カテゴリ分類

3. コスト管理機能
   - API使用量トラッキング
   - コスト計算

**成果物**:
- OpenAI API統合
- 基本的なテキスト処理機能
- コスト管理ダッシュボード

---

### Stage 2-4: 記事生成パイプライン（9日目）

**目標**: 収集データから記事を生成する一連の流れを実装

**作業内容**:
1. 記事生成サービス実装
   - AIを使った記事作成
   - 品質スコアリング

2. データベース保存処理
   - 生成記事の保存
   - ソース情報の関連付け

3. 手動実行インターフェース
   - 管理画面から手動実行
   - 結果確認機能

**成果物**:
- エンドツーエンドの記事生成フロー
- 生成された記事のデータベース保存
- 手動テスト可能な管理画面

---

## Phase 3: 自動化実装（3日間）

### Stage 3-1: Cron Job設定（10日目）

**目標**: 定期実行の仕組みを構築

**作業内容**:
1. Vercel Cron設定
   - cron設定ファイル作成
   - 認証機能実装

2. 定期収集ジョブ実装
   - 毎日の情報収集
   - ジョブ管理

3. 定期生成ジョブ実装
   - 収集データからの記事生成
   - 成功/失敗の記録

**成果物**:
- 動作するCron Job
- ジョブ実行履歴
- エラーログ

---

### Stage 3-2: 通知機能実装（11日目）

**目標**: Slack通知機能の実装

**作業内容**:
1. Slack Webhook設定
   - Webhook URL取得
   - 通知サービス実装

2. 通知テンプレート作成
   - 新記事通知
   - エラー通知

3. 通知条件設定
   - 高スコア記事の通知
   - エラー時の通知

**成果物**:
- 動作するSlack通知
- カスタマイズ可能な通知設定
- 通知履歴

---

### Stage 3-3: エラーハンドリング強化（12日目）

**目標**: システム全体の安定性向上

**作業内容**:
1. 包括的エラーハンドリング
   - 全APIのエラー処理
   - リトライ機能

2. ログシステム実装
   - 構造化ログ
   - ログレベル管理

3. 監視機能
   - ヘルスチェックエンドポイント
   - 基本的なメトリクス

**成果物**:
- 堅牢なエラーハンドリング
- 詳細なログシステム
- システム監視機能

---

## Phase 4: 最適化・公開（2日間）

### Stage 4-1: パフォーマンス最適化（13日目）

**目標**: システムパフォーマンスの向上

**作業内容**:
1. キャッシュ実装
   - Vercel KV設定
   - キャッシュ戦略実装

2. データベース最適化
   - インデックス調整
   - クエリ最適化

3. フロントエンド最適化
   - 画像最適化
   - バンドルサイズ削減

**成果物**:
- 高速化されたシステム
- キャッシュシステム
- 最適化レポート

---

### Stage 4-2: デプロイ・動作確認（14日目）

**目標**: 本番環境へのデプロイと最終確認

**作業内容**:
1. Vercelデプロイ設定
   - 環境変数設定
   - ドメイン設定

2. 本番環境テスト
   - 全機能の動作確認
   - パフォーマンステスト

3. ドキュメント整備
   - README更新
   - 運用手順書作成

**成果物**:
- 本番稼働するシステム
- 完成したドキュメント
- 運用開始

---

## 各フェーズの依存関係

```
Phase 1 → Phase 2 → Phase 3 → Phase 4
（基盤）  （連携）  （自動化） （最適化）
```

- Phase 1が完了しないとPhase 2は開始できない
- Phase 3の一部はPhase 2と並行作業可能
- Phase 4は全フェーズ完了後に実施

## リスク管理

### 想定されるリスクと対策

1. **外部API制限**
   - 対策: 最初は無料枠内で実装、段階的に拡張

2. **AI APIコスト**
   - 対策: 開発中はGPT-4o-miniを使用、本番でGPT-4o

3. **実装遅延**
   - 対策: 各Stageの優先順位を明確化、MVP優先

## 成功の定義

各Stageの完了基準:
- コードがコンパイルエラーなく動作する
- 基本的なテストケースが通る
- ドキュメントが更新されている
- 次のStageに必要な機能が実装されている

## 次のアクション

1. Stage 1-1の実装開始
2. 必要なAPIキーの取得開始
3. 開発環境の準備

この計画に従って、1つずつ着実に実装を進めていきます。