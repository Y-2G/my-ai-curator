# å€‹äººã‚­ãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚µã‚¤ãƒˆ è©³ç´°è¨­è¨ˆæ›¸

## 1. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ 

```
smart-curator/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/                          # Next.js App Router
â”‚   â”‚   â”œâ”€â”€ (main)/                   # ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚°ãƒ«ãƒ¼ãƒ—
â”‚   â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx              # ãƒ›ãƒ¼ãƒ ãƒšãƒ¼ã‚¸
â”‚   â”‚   â”‚   â”œâ”€â”€ articles/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx          # è¨˜äº‹ä¸€è¦§
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ [id]/
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx      # è¨˜äº‹è©³ç´°
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ category/
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ [category]/
â”‚   â”‚   â”‚   â”‚           â””â”€â”€ page.tsx   # ã‚«ãƒ†ã‚´ãƒªåˆ¥è¨˜äº‹
â”‚   â”‚   â”‚   â”œâ”€â”€ search/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx          # æ¤œç´¢ãƒšãƒ¼ã‚¸
â”‚   â”‚   â”‚   â””â”€â”€ tags/
â”‚   â”‚   â”‚       â””â”€â”€ [tag]/
â”‚   â”‚   â”‚           â””â”€â”€ page.tsx       # ã‚¿ã‚°åˆ¥è¨˜äº‹
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”œâ”€â”€ articles/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ route.ts          # GET: è¨˜äº‹ä¸€è¦§
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ [id]/
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ route.ts      # GET: è¨˜äº‹è©³ç´°
â”‚   â”‚   â”‚   â”œâ”€â”€ categories/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts          # GET: ã‚«ãƒ†ã‚´ãƒªä¸€è¦§
â”‚   â”‚   â”‚   â”œâ”€â”€ tags/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ route.ts          # GET: ã‚¿ã‚°ä¸€è¦§
â”‚   â”‚   â”‚   â””â”€â”€ internal/             # å†…éƒ¨APIï¼ˆèªè¨¼å¿…é ˆï¼‰
â”‚   â”‚   â”‚       â”œâ”€â”€ collect/
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ route.ts      # POST: æƒ…å ±åé›†å®Ÿè¡Œ
â”‚   â”‚   â”‚       â”œâ”€â”€ generate/
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ route.ts      # POST: è¨˜äº‹ç”Ÿæˆå®Ÿè¡Œ
â”‚   â”‚   â”‚       â”œâ”€â”€ cron/
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ collect/
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ route.ts  # Cron: å®šæœŸåé›†
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ generate/
â”‚   â”‚   â”‚       â”‚       â””â”€â”€ route.ts  # Cron: å®šæœŸç”Ÿæˆ
â”‚   â”‚   â”‚       â””â”€â”€ jobs/
â”‚   â”‚   â”‚           â””â”€â”€ [id]/
â”‚   â”‚   â”‚               â””â”€â”€ route.ts  # GET: ã‚¸ãƒ§ãƒ–çŠ¶æ³ç¢ºèª
â”‚   â”‚   â”œâ”€â”€ favicon.ico
â”‚   â”‚   â””â”€â”€ globals.css
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ ui/                       # åŸºæœ¬UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Card.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Input.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Badge.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Skeleton.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Modal.tsx
â”‚   â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”‚   â”œâ”€â”€ Header.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Footer.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Sidebar.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Navigation.tsx
â”‚   â”‚   â”œâ”€â”€ article/
â”‚   â”‚   â”‚   â”œâ”€â”€ ArticleCard.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ ArticleList.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ ArticleDetail.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ ArticleSearch.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ CategoryBadge.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ TagList.tsx
â”‚   â”‚   â”‚   â””â”€â”€ InterestScore.tsx
â”‚   â”‚   â””â”€â”€ common/
â”‚   â”‚       â”œâ”€â”€ Loading.tsx
â”‚   â”‚       â”œâ”€â”€ ErrorBoundary.tsx
â”‚   â”‚       â”œâ”€â”€ Pagination.tsx
â”‚   â”‚       â””â”€â”€ SEO.tsx
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ api/                      # APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ client.ts             # HTTPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨­å®š
â”‚   â”‚   â”‚   â”œâ”€â”€ articles.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ categories.ts
â”‚   â”‚   â”‚   â””â”€â”€ internal.ts
â”‚   â”‚   â”œâ”€â”€ db/                       # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é–¢é€£
â”‚   â”‚   â”‚   â”œâ”€â”€ prisma.ts             # Prismaã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ article.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ category.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tag.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ source.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user.ts
â”‚   â”‚   â”‚   â””â”€â”€ migrations/
â”‚   â”‚   â”œâ”€â”€ ai/                       # AIã‚µãƒ¼ãƒ“ã‚¹
â”‚   â”‚   â”‚   â”œâ”€â”€ client.ts             # AI APIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
â”‚   â”‚   â”‚   â”œâ”€â”€ prompts/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ search-query.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ article-generation.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ categorization.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ quality-evaluation.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ article-generator.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ content-evaluator.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ interest-calculator.ts
â”‚   â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”‚   â”œâ”€â”€ collectors/               # æƒ…å ±åé›†ã‚µãƒ¼ãƒ“ã‚¹
â”‚   â”‚   â”‚   â”œâ”€â”€ base.ts               # åŸºåº•ã‚¯ãƒ©ã‚¹
â”‚   â”‚   â”‚   â”œâ”€â”€ google-search.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ news-api.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ reddit.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ github.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ rss-parser.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ notifications/            # é€šçŸ¥ã‚µãƒ¼ãƒ“ã‚¹
â”‚   â”‚   â”‚   â”œâ”€â”€ slack.ts
â”‚   â”‚   â”‚   â””â”€â”€ types.ts
â”‚   â”‚   â”œâ”€â”€ utils/                    # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
â”‚   â”‚   â”‚   â”œâ”€â”€ date.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ string.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ validation.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ logger.ts
â”‚   â”‚   â”‚   â””â”€â”€ error-handler.ts
â”‚   â”‚   â”œâ”€â”€ cache/                    # ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ redis.ts
â”‚   â”‚   â”‚   â””â”€â”€ strategies.ts
â”‚   â”‚   â”œâ”€â”€ types/                    # å‹å®šç¾©
â”‚   â”‚   â”‚   â”œâ”€â”€ article.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ api.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ database.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ constants/                # å®šæ•°
â”‚   â”‚       â”œâ”€â”€ api.ts
â”‚   â”‚       â”œâ”€â”€ config.ts
â”‚   â”‚       â””â”€â”€ ui.ts
â”‚   â”œâ”€â”€ hooks/                        # ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯
â”‚   â”‚   â”œâ”€â”€ useArticles.ts
â”‚   â”‚   â”œâ”€â”€ useCategories.ts
â”‚   â”‚   â”œâ”€â”€ useSearch.ts
â”‚   â”‚   â”œâ”€â”€ usePagination.ts
â”‚   â”‚   â””â”€â”€ useDebounce.ts
â”‚   â””â”€â”€ middleware.ts                 # Next.jsãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma                 # Prismaã‚¹ã‚­ãƒ¼ãƒ
â”‚   â””â”€â”€ seed.ts                       # ã‚·ãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ images/
â”‚   â””â”€â”€ robots.txt
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ e2e/
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ next.config.ts
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tailwind.config.ts
â””â”€â”€ README.md
```

## 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è©³ç´°è¨­è¨ˆ

### 2.1 Prisma Schema

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String    @id @default(uuid())
  email      String    @unique
  name       String
  profile    Json      @default("{}")
  interests  Json      @default("{}")
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  articles   Article[]
  userInterests UserInterest[]

  @@index([email])
}

model Category {
  id          String    @id @default(uuid())
  name        String    @unique
  description String?
  color       String    @default("#000000")
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  articles    Article[]

  @@index([name])
}

model Article {
  id            String    @id @default(uuid())
  title         String
  summary       String
  content       String    @db.Text
  categoryId    String?
  authorId      String?
  interestScore Int       @default(0)
  qualityScore  Int       @default(0)
  publishedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  category      Category? @relation(fields: [categoryId], references: [id])
  author        User?     @relation(fields: [authorId], references: [id])
  sources       Source[]
  articleTags   ArticleTag[]

  @@index([publishedAt(sort: Desc)])
  @@index([categoryId])
  @@index([interestScore(sort: Desc)])
  @@index([createdAt(sort: Desc)])
}

model Source {
  id        String   @id @default(uuid())
  articleId String
  url       String
  title     String?
  type      String   // 'google', 'news', 'reddit', 'github', 'rss'
  createdAt DateTime @default(now())

  article   Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@index([articleId])
  @@index([type])
}

model Tag {
  id          String   @id @default(uuid())
  name        String   @unique
  createdAt   DateTime @default(now())

  articleTags ArticleTag[]

  @@index([name])
}

model ArticleTag {
  id        String   @id @default(uuid())
  articleId String
  tagId     String
  createdAt DateTime @default(now())

  article   Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id])

  @@unique([articleId, tagId])
  @@index([articleId])
  @@index([tagId])
}

model CollectionJob {
  id              String    @id @default(uuid())
  status          String    @default("pending") // 'pending', 'running', 'completed', 'failed'
  startedAt       DateTime?
  completedAt     DateTime?
  errorMessage    String?
  articlesCreated Int       @default(0)
  metadata        Json?
  createdAt       DateTime  @default(now())

  @@index([status])
  @@index([createdAt(sort: Desc)])
}

model UserInterest {
  id        String   @id @default(uuid())
  userId    String
  keyword   String
  weight    Float    @default(1.0)
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, keyword])
  @@index([userId])
  @@index([weight(sort: Desc)])
}
```

### 2.2 ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹å±¤å®Ÿè£…

```typescript
// src/lib/db/models/article.ts
import { prisma } from '@/lib/db/prisma';
import type { Article, Prisma } from '@prisma/client';

export interface ArticleWithRelations extends Article {
  category: Category | null;
  sources: Source[];
  articleTags: (ArticleTag & { tag: Tag })[];
}

export interface ArticleListParams {
  page?: number;
  limit?: number;
  categoryId?: string;
  tagId?: string;
  sort?: 'createdAt' | 'interestScore' | 'qualityScore';
  order?: 'asc' | 'desc';
}

export class ArticleModel {
  static async findMany(params: ArticleListParams): Promise<{
    articles: ArticleWithRelations[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20, categoryId, tagId, sort = 'createdAt', order = 'desc' } = params;

    const where: Prisma.ArticleWhereInput = {
      publishedAt: { not: null },
    };

    if (categoryId) {
      where.categoryId = categoryId;
    }

    if (tagId) {
      where.articleTags = {
        some: { tagId },
      };
    }

    const [articles, total] = await Promise.all([
      prisma.article.findMany({
        where,
        include: {
          category: true,
          sources: true,
          articleTags: {
            include: { tag: true },
          },
        },
        orderBy: { [sort]: order },
        skip: (page - 1) * limit,
        take: limit,
      }),
      prisma.article.count({ where }),
    ]);

    return {
      articles,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  static async findById(id: string): Promise<ArticleWithRelations | null> {
    return prisma.article.findUnique({
      where: { id },
      include: {
        category: true,
        sources: true,
        articleTags: {
          include: { tag: true },
        },
      },
    });
  }

  static async create(data: {
    title: string;
    summary: string;
    content: string;
    categoryId?: string;
    authorId?: string;
    sources: { url: string; title?: string; type: string }[];
    tags: string[];
    interestScore: number;
    qualityScore: number;
  }): Promise<ArticleWithRelations> {
    const { sources, tags, ...articleData } = data;

    return prisma.$transaction(async (tx) => {
      // è¨˜äº‹ä½œæˆ
      const article = await tx.article.create({
        data: {
          ...articleData,
          publishedAt: new Date(),
        },
      });

      // ã‚½ãƒ¼ã‚¹ä½œæˆ
      if (sources.length > 0) {
        await tx.source.createMany({
          data: sources.map((source) => ({
            ...source,
            articleId: article.id,
          })),
        });
      }

      // ã‚¿ã‚°å‡¦ç†
      if (tags.length > 0) {
        // æ—¢å­˜ã‚¿ã‚°å–å¾—ã¾ãŸã¯ä½œæˆ
        const tagRecords = await Promise.all(
          tags.map(async (tagName) => {
            return tx.tag.upsert({
              where: { name: tagName },
              update: {},
              create: { name: tagName },
            });
          })
        );

        // ArticleTagä½œæˆ
        await tx.articleTag.createMany({
          data: tagRecords.map((tag) => ({
            articleId: article.id,
            tagId: tag.id,
          })),
        });
      }

      // å®Œå…¨ãªãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—
      return tx.article.findUnique({
        where: { id: article.id },
        include: {
          category: true,
          sources: true,
          articleTags: {
            include: { tag: true },
          },
        },
      }) as Promise<ArticleWithRelations>;
    });
  }

  static async updateInterestScore(id: string, score: number): Promise<void> {
    await prisma.article.update({
      where: { id },
      data: { interestScore: score },
    });
  }
}
```

## 3. APIå®Ÿè£…è©³ç´°

### 3.1 è¨˜äº‹ä¸€è¦§API

```typescript
// src/app/api/articles/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { ArticleModel } from '@/lib/db/models/article';
import { withErrorHandler } from '@/lib/utils/error-handler';
import { cacheStrategy } from '@/lib/cache/strategies';

const querySchema = z.object({
  page: z.coerce.number().min(1).optional(),
  limit: z.coerce.number().min(1).max(100).optional(),
  category: z.string().uuid().optional(),
  tag: z.string().uuid().optional(),
  sort: z.enum(['createdAt', 'interestScore', 'qualityScore']).optional(),
  order: z.enum(['asc', 'desc']).optional(),
});

export async function GET(request: NextRequest) {
  return withErrorHandler(async () => {
    const searchParams = Object.fromEntries(request.nextUrl.searchParams);
    const query = querySchema.parse(searchParams);

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
    const cacheKey = `articles:${JSON.stringify(query)}`;
    const cached = await cacheStrategy.get(cacheKey);
    if (cached) {
      return NextResponse.json(cached);
    }

    const result = await ArticleModel.findMany({
      page: query.page,
      limit: query.limit,
      categoryId: query.category,
      tagId: query.tag,
      sort: query.sort,
      order: query.order,
    });

    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼å¤‰æ›
    const response = {
      articles: result.articles.map((article) => ({
        id: article.id,
        title: article.title,
        summary: article.summary,
        category: article.category
          ? {
              id: article.category.id,
              name: article.category.name,
              color: article.category.color,
            }
          : null,
        tags: article.articleTags.map((at) => ({
          id: at.tag.id,
          name: at.tag.name,
        })),
        interestScore: article.interestScore,
        qualityScore: article.qualityScore,
        publishedAt: article.publishedAt?.toISOString(),
        createdAt: article.createdAt.toISOString(),
      })),
      pagination: {
        page: result.page,
        limit: query.limit || 20,
        total: result.total,
        totalPages: result.totalPages,
      },
    };

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¿å­˜ï¼ˆ15åˆ†ï¼‰
    await cacheStrategy.set(cacheKey, response, 900);

    return NextResponse.json(response);
  });
}
```

### 3.2 æƒ…å ±åé›†API

```typescript
// src/app/api/internal/collect/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { verifyInternalApiKey } from '@/lib/auth/middleware';
import { CollectorManager } from '@/lib/collectors';
import { CollectionJobModel } from '@/lib/db/models/collection-job';
import { withErrorHandler } from '@/lib/utils/error-handler';
import { Logger } from '@/lib/utils/logger';

const requestSchema = z.object({
  sources: z.array(z.enum(['google', 'news', 'reddit', 'github', 'rss'])),
  limit: z.number().min(1).max(100).default(20),
});

export async function POST(request: NextRequest) {
  // å†…éƒ¨APIèªè¨¼
  const authResult = await verifyInternalApiKey(request);
  if (!authResult.valid) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  return withErrorHandler(async () => {
    const body = await request.json();
    const { sources, limit } = requestSchema.parse(body);

    // ã‚¸ãƒ§ãƒ–ä½œæˆ
    const job = await CollectionJobModel.create();

    // éåŒæœŸã§åé›†é–‹å§‹
    collectAsync(job.id, sources, limit);

    return NextResponse.json({
      jobId: job.id,
      status: 'started',
      message: 'Collection job started',
    });
  });
}

async function collectAsync(jobId: string, sources: string[], limit: number): Promise<void> {
  const logger = new Logger('CollectionJob');

  try {
    await CollectionJobModel.updateStatus(jobId, 'running');

    const collectorManager = new CollectorManager();
    const results = await collectorManager.collectFromMultipleSources(sources, limit);

    logger.info(`Collected ${results.length} items from ${sources.join(', ')}`, {
      jobId,
      sources,
      resultCount: results.length,
    });

    await CollectionJobModel.complete(jobId, {
      articlesCreated: 0, // è¨˜äº‹ç”Ÿæˆå‰ãªã®ã§0
      metadata: {
        sources,
        collectedItems: results.length,
        timestamp: new Date().toISOString(),
      },
    });

    // åé›†ãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ™‚ä¿å­˜ï¼ˆå¾Œç¶šã®ç”Ÿæˆå‡¦ç†ã§ä½¿ç”¨ï¼‰
    await cacheStrategy.set(
      `collection:${jobId}`,
      results,
      3600 // 1æ™‚é–“ä¿æŒ
    );
  } catch (error) {
    logger.error('Collection job failed', error as Error, { jobId });
    await CollectionJobModel.fail(jobId, error instanceof Error ? error.message : 'Unknown error');
  }
}
```

### 3.3 è¨˜äº‹ç”ŸæˆAPI

```typescript
// src/app/api/internal/generate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { verifyInternalApiKey } from '@/lib/auth/middleware';
import { ArticleGenerator } from '@/lib/ai/services/article-generator';
import { ContentEvaluator } from '@/lib/ai/services/content-evaluator';
import { InterestCalculator } from '@/lib/ai/services/interest-calculator';
import { ArticleModel } from '@/lib/db/models/article';
import { UserModel } from '@/lib/db/models/user';
import { NotificationService } from '@/lib/notifications/slack';
import { withErrorHandler } from '@/lib/utils/error-handler';
import { Logger } from '@/lib/utils/logger';

const requestSchema = z.object({
  jobId: z.string().optional(),
  userId: z.string().uuid(),
  rawData: z
    .array(
      z.object({
        title: z.string(),
        url: z.string(),
        summary: z.string(),
        publishedAt: z.string(),
        source: z.string(),
        type: z.string(),
        metadata: z.record(z.any()),
      })
    )
    .optional(),
});

export async function POST(request: NextRequest) {
  const authResult = await verifyInternalApiKey(request);
  if (!authResult.valid) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  return withErrorHandler(async () => {
    const body = await request.json();
    const { jobId, userId, rawData: providedData } = requestSchema.parse(body);

    // ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¾ãŸã¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã‹ã‚‰ï¼‰
    let rawData = providedData;
    if (!rawData && jobId) {
      rawData = await cacheStrategy.get(`collection:${jobId}`);
      if (!rawData) {
        return NextResponse.json({ error: 'Collection data not found' }, { status: 404 });
      }
    }

    if (!rawData || rawData.length === 0) {
      return NextResponse.json({ error: 'No data to generate articles from' }, { status: 400 });
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—
    const user = await UserModel.findById(userId);
    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    const logger = new Logger('ArticleGeneration');
    const generator = new ArticleGenerator();
    const evaluator = new ContentEvaluator();
    const interestCalculator = new InterestCalculator();
    const notificationService = new NotificationService();

    const generatedArticles = [];

    // å„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è©•ä¾¡ãƒ»å‡¦ç†
    for (const content of rawData) {
      try {
        // å“è³ªè©•ä¾¡
        const qualityScore = await evaluator.evaluate(content);
        if (qualityScore < 5) {
          logger.info('Content quality too low, skipping', {
            url: content.url,
            qualityScore,
          });
          continue;
        }

        // èˆˆå‘³åº¦è¨ˆç®—
        const interestScore = await interestCalculator.calculate(content, user.profile as any);
        if (interestScore < 3) {
          logger.info('Content interest too low, skipping', {
            url: content.url,
            interestScore,
          });
          continue;
        }

        // è¨˜äº‹ç”Ÿæˆ
        const article = await generator.generate([content], user.profile as any);

        // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¿å­˜
        const savedArticle = await ArticleModel.create({
          ...article,
          authorId: userId,
          interestScore,
          qualityScore,
        });

        generatedArticles.push(savedArticle);

        logger.info('Article generated successfully', {
          articleId: savedArticle.id,
          title: savedArticle.title,
        });
      } catch (error) {
        logger.error('Failed to generate article', error as Error, {
          url: content.url,
        });
      }
    }

    // é«˜å“è³ªè¨˜äº‹ã®ã¿é€šçŸ¥
    const highQualityArticles = generatedArticles.filter((article) => article.interestScore >= 7);

    if (highQualityArticles.length > 0) {
      await notificationService.notifyNewArticles(highQualityArticles);
    }

    return NextResponse.json({
      success: true,
      articlesGenerated: generatedArticles.length,
      articles: generatedArticles.map((article) => ({
        id: article.id,
        title: article.title,
        interestScore: article.interestScore,
        qualityScore: article.qualityScore,
      })),
    });
  });
}
```

## 4. AIå‡¦ç†å®Ÿè£…

### 4.1 è¨˜äº‹ç”Ÿæˆã‚µãƒ¼ãƒ“ã‚¹

```typescript
// src/lib/ai/services/article-generator.ts
import { OpenAI } from 'openai';
import { z } from 'zod';
import { ARTICLE_GENERATION_PROMPT } from '@/lib/ai/prompts/article-generation';
import type { RawContentData, GeneratedArticle } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';

const generatedArticleSchema = z.object({
  title: z.string(),
  summary: z.string(),
  content: z.string(),
  category: z.string(),
  tags: z.array(z.string()),
  confidence: z.number(),
});

export class ArticleGenerator {
  private openai: OpenAI;
  private logger: Logger;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    this.logger = new Logger('ArticleGenerator');
  }

  async generate(
    sources: RawContentData[],
    userProfile: {
      techLevel: string;
      interests: string[];
      preferredStyle: string;
    }
  ): Promise<GeneratedArticle> {
    const prompt = this.buildPrompt(sources, userProfile);

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content:
              'ã‚ãªãŸã¯æŠ€è¡“ç³»ãƒ–ãƒ­ã‚°ã®ãƒ©ã‚¤ã‚¿ãƒ¼ã§ã™ã€‚æä¾›ã•ã‚ŒãŸæƒ…å ±ã‹ã‚‰é­…åŠ›çš„ãªè¨˜äº‹ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.7,
        response_format: { type: 'json_object' },
      });

      const content = response.choices[0].message.content;
      if (!content) {
        throw new Error('No content generated');
      }

      const parsed = JSON.parse(content);
      const validated = generatedArticleSchema.parse(parsed);

      return {
        ...validated,
        sources: sources.map((s) => ({
          url: s.url,
          title: s.title,
          type: s.type,
        })),
      };
    } catch (error) {
      this.logger.error('Failed to generate article', error as Error);
      throw error;
    }
  }

  private buildPrompt(
    sources: RawContentData[],
    userProfile: {
      techLevel: string;
      interests: string[];
      preferredStyle: string;
    }
  ): string {
    const sourcesText = sources
      .map((s) => `- ${s.title}\n  URL: ${s.url}\n  è¦ç´„: ${s.summary}`)
      .join('\n\n');

    return ARTICLE_GENERATION_PROMPT.replace('{{user.techLevel}}', userProfile.techLevel)
      .replace('{{user.interests}}', userProfile.interests.join(', '))
      .replace('{{user.preferredStyle}}', userProfile.preferredStyle)
      .replace('{{sources}}', sourcesText);
  }
}
```

### 4.2 èˆˆå‘³åº¦è¨ˆç®—ã‚µãƒ¼ãƒ“ã‚¹

```typescript
// src/lib/ai/services/interest-calculator.ts
import { OpenAI } from 'openai';
import type { RawContentData } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';

export class InterestCalculator {
  private openai: OpenAI;
  private logger: Logger;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    this.logger = new Logger('InterestCalculator');
  }

  async calculate(
    content: RawContentData,
    userProfile: {
      interests: string[];
      recentTopics: string[];
      techLevel: string;
    }
  ): Promise<number> {
    const prompt = `
ä»¥ä¸‹ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã€æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«ã©ã®ç¨‹åº¦èˆˆå‘³æ·±ã„ã‹ã‚’1-10ã®ã‚¹ã‚³ã‚¢ã§è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚

# ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«
- èˆˆå‘³åˆ†é‡: ${userProfile.interests.join(', ')}
- æœ€è¿‘ã®é–¢å¿ƒäº‹: ${userProfile.recentTopics.join(', ')}
- æŠ€è¡“ãƒ¬ãƒ™ãƒ«: ${userProfile.techLevel}

# ã‚³ãƒ³ãƒ†ãƒ³ãƒ„
ã‚¿ã‚¤ãƒˆãƒ«: ${content.title}
è¦ç´„: ${content.summary}
ã‚½ãƒ¼ã‚¹: ${content.source}

# è©•ä¾¡åŸºæº–
- èˆˆå‘³åˆ†é‡ã¨ã®é–¢é€£æ€§ï¼ˆ40%ï¼‰
- æ–°è¦æ€§ãƒ»ãƒˆãƒ¬ãƒ³ãƒ‰æ€§ï¼ˆ30%ï¼‰
- æŠ€è¡“ãƒ¬ãƒ™ãƒ«ã®é©åˆæ€§ï¼ˆ20%ï¼‰
- å®Ÿç”¨æ€§ï¼ˆ10%ï¼‰

ã‚¹ã‚³ã‚¢ã®ã¿ã‚’æ•°å€¤ã§å›ç­”ã—ã¦ãã ã•ã„ã€‚
`;

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.3,
        max_tokens: 10,
      });

      const scoreText = response.choices[0].message.content?.trim();
      const score = parseInt(scoreText || '0', 10);

      if (isNaN(score) || score < 1 || score > 10) {
        this.logger.warn('Invalid interest score', { scoreText });
        return 5; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
      }

      return score;
    } catch (error) {
      this.logger.error('Failed to calculate interest score', error as Error);
      return 5; // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
    }
  }
}
```

## 5. æƒ…å ±åé›†å®Ÿè£…

### 5.1 åé›†ã‚µãƒ¼ãƒ“ã‚¹åŸºåº•ã‚¯ãƒ©ã‚¹

```typescript
// src/lib/collectors/base.ts
import type { RawContentData } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';
import { RateLimiter } from '@/lib/utils/rate-limiter';

export abstract class BaseCollector {
  protected logger: Logger;
  protected rateLimiter: RateLimiter;

  constructor(protected name: string) {
    this.logger = new Logger(`Collector:${name}`);
    this.rateLimiter = new RateLimiter();
  }

  abstract collect(query: string, limit: number): Promise<RawContentData[]>;

  async isRateLimited(): Promise<boolean> {
    return this.rateLimiter.isLimited(`collector:${this.name}`);
  }

  async getNextAvailableTime(): Promise<Date | null> {
    return this.rateLimiter.getNextAvailableTime(`collector:${this.name}`);
  }

  protected async trackApiCall(): Promise<void> {
    await this.rateLimiter.track(`collector:${this.name}`);
  }

  protected transformToRawContent(data: any): RawContentData {
    // å„åé›†ã‚µãƒ¼ãƒ“ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
    throw new Error('transformToRawContent must be implemented');
  }
}
```

### 5.2 Googleæ¤œç´¢åé›†ã‚µãƒ¼ãƒ“ã‚¹

```typescript
// src/lib/collectors/google-search.ts
import axios from 'axios';
import { BaseCollector } from './base';
import type { RawContentData } from '@/lib/types';

interface GoogleSearchResult {
  title: string;
  link: string;
  snippet: string;
  pagemap?: {
    metatags?: Array<{
      'og:description'?: string;
      'article:published_time'?: string;
    }>;
  };
}

export class GoogleSearchCollector extends BaseCollector {
  private apiKey: string;
  private searchEngineId: string;

  constructor() {
    super('GoogleSearch');
    this.apiKey = process.env.GOOGLE_CUSTOM_SEARCH_API_KEY!;
    this.searchEngineId = process.env.GOOGLE_SEARCH_ENGINE_ID!;
  }

  async collect(query: string, limit: number): Promise<RawContentData[]> {
    await this.trackApiCall();

    try {
      const response = await axios.get('https://www.googleapis.com/customsearch/v1', {
        params: {
          key: this.apiKey,
          cx: this.searchEngineId,
          q: query,
          num: Math.min(limit, 10), // Google APIã¯æœ€å¤§10ä»¶
          sort: 'date',
        },
      });

      const items = response.data.items || [];

      return items.map((item: GoogleSearchResult) => this.transformToRawContent(item));
    } catch (error) {
      this.logger.error('Failed to collect from Google', error as Error);
      return [];
    }
  }

  protected transformToRawContent(item: GoogleSearchResult): RawContentData {
    const publishedAt =
      item.pagemap?.metatags?.[0]?.['article:published_time'] || new Date().toISOString();

    return {
      title: item.title,
      url: item.link,
      summary: item.snippet,
      publishedAt,
      source: 'Google Search',
      type: 'google',
      metadata: {
        pagemap: item.pagemap,
      },
    };
  }
}
```

### 5.3 åé›†ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

```typescript
// src/lib/collectors/index.ts
import { GoogleSearchCollector } from './google-search';
import { NewsApiCollector } from './news-api';
import { RedditCollector } from './reddit';
import { GitHubCollector } from './github';
import { RssCollector } from './rss-parser';
import type { RawContentData } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';

export class CollectorManager {
  private collectors: Map<string, BaseCollector>;
  private logger: Logger;

  constructor() {
    this.logger = new Logger('CollectorManager');
    this.collectors = new Map([
      ['google', new GoogleSearchCollector()],
      ['news', new NewsApiCollector()],
      ['reddit', new RedditCollector()],
      ['github', new GitHubCollector()],
      ['rss', new RssCollector()],
    ]);
  }

  async collectFromMultipleSources(
    sources: string[],
    limitPerSource: number
  ): Promise<RawContentData[]> {
    const results: RawContentData[] = [];
    const errors: Array<{ source: string; error: string }> = [];

    // ä¸¦åˆ—åé›†
    const promises = sources.map(async (source) => {
      const collector = this.collectors.get(source);
      if (!collector) {
        errors.push({ source, error: 'Collector not found' });
        return [];
      }

      try {
        // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
        if (await collector.isRateLimited()) {
          const nextTime = await collector.getNextAvailableTime();
          this.logger.warn(`${source} is rate limited`, { nextTime });
          return [];
        }

        // AIç”Ÿæˆã®æ¤œç´¢ã‚¯ã‚¨ãƒª
        const queries = await this.generateSearchQueries(source);
        const allResults: RawContentData[] = [];

        for (const query of queries) {
          const items = await collector.collect(query, limitPerSource);
          allResults.push(...items);
        }

        return allResults;
      } catch (error) {
        errors.push({
          source,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
        return [];
      }
    });

    const sourceResults = await Promise.all(promises);
    sourceResults.forEach((items) => results.push(...items));

    // é‡è¤‡é™¤å»
    const uniqueResults = this.removeDuplicates(results);

    this.logger.info('Collection completed', {
      totalCollected: uniqueResults.length,
      sources,
      errors,
    });

    return uniqueResults;
  }

  private async generateSearchQueries(source: string): Promise<string[]> {
    // TODO: AI ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ã«åŸºã¥ã„ãŸæ¤œç´¢ã‚¯ã‚¨ãƒªã‚’ç”Ÿæˆ
    // ä»®å®Ÿè£…
    const baseQueries = [
      'Next.js 15 new features',
      'TypeScript best practices 2024',
      'AI development tools',
      'web performance optimization',
    ];

    // ã‚½ãƒ¼ã‚¹ã”ã¨ã«æœ€é©åŒ–
    switch (source) {
      case 'reddit':
        return baseQueries.map((q) => `${q} site:reddit.com`);
      case 'github':
        return ['trending repositories', 'new releases'];
      default:
        return baseQueries;
    }
  }

  private removeDuplicates(items: RawContentData[]): RawContentData[] {
    const seen = new Set<string>();
    return items.filter((item) => {
      const key = item.url;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }
}
```

## 6. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Ÿè£…

### 6.1 è¨˜äº‹ä¸€è¦§ãƒšãƒ¼ã‚¸

```tsx
// src/app/(main)/articles/page.tsx
import { Suspense } from 'react';
import { ArticleList } from '@/components/article/ArticleList';
import { CategoryFilter } from '@/components/article/CategoryFilter';
import { SearchBar } from '@/components/common/SearchBar';
import { Loading } from '@/components/common/Loading';
import { getArticles, getCategories } from '@/lib/api/server';

interface PageProps {
  searchParams: {
    page?: string;
    category?: string;
    search?: string;
  };
}

export default async function ArticlesPage({ searchParams }: PageProps) {
  const page = parseInt(searchParams.page || '1', 10);
  const categoryId = searchParams.category;
  const search = searchParams.search;

  const [articlesData, categories] = await Promise.all([
    getArticles({ page, categoryId, search }),
    getCategories(),
  ]);

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">è¨˜äº‹ä¸€è¦§</h1>

      <div className="mb-6 space-y-4">
        <SearchBar defaultValue={search} />
        <CategoryFilter categories={categories} selectedCategoryId={categoryId} />
      </div>

      <Suspense fallback={<Loading />}>
        <ArticleList articles={articlesData.articles} pagination={articlesData.pagination} />
      </Suspense>
    </div>
  );
}

export async function generateMetadata({ searchParams }: PageProps) {
  const page = searchParams.page || '1';

  return {
    title: `è¨˜äº‹ä¸€è¦§ - ãƒšãƒ¼ã‚¸ ${page}`,
    description: 'AIãŒã‚­ãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã—ãŸæœ€æ–°è¨˜äº‹ä¸€è¦§',
  };
}
```

### 6.2 è¨˜äº‹è©³ç´°ãƒšãƒ¼ã‚¸

```tsx
// src/app/(main)/articles/[id]/page.tsx
import { notFound } from 'next/navigation';
import { ArticleDetail } from '@/components/article/ArticleDetail';
import { RelatedArticles } from '@/components/article/RelatedArticles';
import { getArticleById, getRelatedArticles } from '@/lib/api/server';

interface PageProps {
  params: {
    id: string;
  };
}

export default async function ArticlePage({ params }: PageProps) {
  const article = await getArticleById(params.id);

  if (!article) {
    notFound();
  }

  const relatedArticles = await getRelatedArticles(params.id);

  return (
    <div className="container mx-auto px-4 py-8">
      <ArticleDetail article={article} />

      {relatedArticles.length > 0 && (
        <div className="mt-12">
          <h2 className="text-2xl font-bold mb-6">é–¢é€£è¨˜äº‹</h2>
          <RelatedArticles articles={relatedArticles} />
        </div>
      )}
    </div>
  );
}

export async function generateMetadata({ params }: PageProps) {
  const article = await getArticleById(params.id);

  if (!article) {
    return {
      title: 'è¨˜äº‹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',
    };
  }

  return {
    title: article.title,
    description: article.summary,
    openGraph: {
      title: article.title,
      description: article.summary,
      type: 'article',
      publishedTime: article.publishedAt,
      authors: ['AI Curator'],
      tags: article.tags.map((t) => t.name),
    },
  };
}

export async function generateStaticParams() {
  // æœ€æ–°50è¨˜äº‹ã‚’SSGå¯¾è±¡ã¨ã™ã‚‹
  const articles = await getRecentArticles(50);

  return articles.map((article) => ({
    id: article.id,
  }));
}
```

### 6.3 è¨˜äº‹ã‚«ãƒ¼ãƒ‰ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ

```tsx
// src/components/article/ArticleCard.tsx
'use client';

import Link from 'next/link';
import { formatDistanceToNow } from 'date-fns';
import { ja } from 'date-fns/locale';
import { CategoryBadge } from './CategoryBadge';
import { TagList } from './TagList';
import { InterestScore } from './InterestScore';
import { Card } from '@/components/ui/Card';
import type { Article } from '@/lib/types';

interface ArticleCardProps {
  article: Article;
  variant?: 'default' | 'featured' | 'compact';
}

export function ArticleCard({ article, variant = 'default' }: ArticleCardProps) {
  const isCompact = variant === 'compact';
  const isFeatured = variant === 'featured';

  return (
    <Card
      className={`
        hover:shadow-lg transition-shadow duration-200
        ${isFeatured ? 'border-2 border-blue-500' : ''}
      `}
      padding={isCompact ? 'sm' : 'md'}
    >
      <article>
        <div className="flex items-start justify-between mb-3">
          {article.category && <CategoryBadge category={article.category} />}
          <InterestScore score={article.interestScore} />
        </div>

        <h3
          className={`
          font-semibold mb-2 line-clamp-2
          ${isCompact ? 'text-lg' : 'text-xl'}
        `}
        >
          <Link href={`/articles/${article.id}`} className="hover:text-blue-600 transition-colors">
            {article.title}
          </Link>
        </h3>

        {!isCompact && <p className="text-gray-600 mb-3 line-clamp-3">{article.summary}</p>}

        <div className="flex items-center justify-between text-sm text-gray-500">
          <TagList tags={article.tags} limit={isCompact ? 2 : 3} />
          <time
            dateTime={article.publishedAt}
            title={new Date(article.publishedAt).toLocaleString('ja-JP')}
          >
            {formatDistanceToNow(new Date(article.publishedAt), {
              addSuffix: true,
              locale: ja,
            })}
          </time>
        </div>
      </article>
    </Card>
  );
}
```

## 7. Cron Jobå®Ÿè£…

### 7.1 å®šæœŸåé›†Cron

```typescript
// src/app/api/internal/cron/collect/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyVercelCron } from '@/lib/auth/cron';
import { CollectorManager } from '@/lib/collectors';
import { CollectionJobModel } from '@/lib/db/models/collection-job';
import { UserModel } from '@/lib/db/models/user';
import { cacheStrategy } from '@/lib/cache/strategies';
import { Logger } from '@/lib/utils/logger';

export async function GET(request: NextRequest) {
  // Vercel Cronèªè¨¼
  const isValid = await verifyVercelCron(request);
  if (!isValid) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const logger = new Logger('CronCollect');

  try {
    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼å–å¾—
    const users = await UserModel.findActiveUsers();
    logger.info(`Starting collection for ${users.length} users`);

    const collectorManager = new CollectorManager();
    const allResults = [];

    // å„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã«åé›†
    for (const user of users) {
      const job = await CollectionJobModel.create({
        metadata: { userId: user.id },
      });

      try {
        await CollectionJobModel.updateStatus(job.id, 'running');

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®èˆˆå‘³ã«åŸºã¥ã„ã¦åé›†
        const sources = ['google', 'news', 'reddit', 'github'];
        const results = await collectorManager.collectFromMultipleSources(
          sources,
          10 // å„ã‚½ãƒ¼ã‚¹ã‹ã‚‰10ä»¶
        );

        // çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        await cacheStrategy.set(`collection:${job.id}`, results, 3600);

        await CollectionJobModel.complete(job.id, {
          articlesCreated: 0,
          metadata: {
            userId: user.id,
            collectedItems: results.length,
            sources,
          },
        });

        allResults.push({
          userId: user.id,
          jobId: job.id,
          itemsCollected: results.length,
        });
      } catch (error) {
        logger.error(`Collection failed for user ${user.id}`, error as Error);
        await CollectionJobModel.fail(
          job.id,
          error instanceof Error ? error.message : 'Unknown error'
        );
      }
    }

    logger.info('Collection cron completed', { results: allResults });

    return NextResponse.json({
      success: true,
      results: allResults,
    });
  } catch (error) {
    logger.error('Collection cron failed', error as Error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export const runtime = 'nodejs';
export const maxDuration = 300; // 5åˆ†
```

### 7.2 å®šæœŸç”ŸæˆCron

```typescript
// src/app/api/internal/cron/generate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyVercelCron } from '@/lib/auth/cron';
import { ArticleGenerator } from '@/lib/ai/services/article-generator';
import { ContentEvaluator } from '@/lib/ai/services/content-evaluator';
import { InterestCalculator } from '@/lib/ai/services/interest-calculator';
import { ArticleModel } from '@/lib/db/models/article';
import { CollectionJobModel } from '@/lib/db/models/collection-job';
import { NotificationService } from '@/lib/notifications/slack';
import { cacheStrategy } from '@/lib/cache/strategies';
import { Logger } from '@/lib/utils/logger';

export async function GET(request: NextRequest) {
  const isValid = await verifyVercelCron(request);
  if (!isValid) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const logger = new Logger('CronGenerate');

  try {
    // æœªå‡¦ç†ã®åé›†ã‚¸ãƒ§ãƒ–ã‚’å–å¾—
    const pendingJobs = await CollectionJobModel.findPendingJobs();
    logger.info(`Processing ${pendingJobs.length} pending jobs`);

    const generator = new ArticleGenerator();
    const evaluator = new ContentEvaluator();
    const interestCalculator = new InterestCalculator();
    const notificationService = new NotificationService();

    const allGeneratedArticles = [];

    for (const job of pendingJobs) {
      const userId = job.metadata?.userId as string;
      if (!userId) continue;

      // åé›†ãƒ‡ãƒ¼ã‚¿å–å¾—
      const rawData = await cacheStrategy.get(`collection:${job.id}`);
      if (!rawData || !Array.isArray(rawData)) {
        logger.warn(`No data found for job ${job.id}`);
        continue;
      }

      const generatedArticles = [];

      // ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦è¨˜äº‹ç”Ÿæˆï¼ˆé¡ä¼¼ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ã¾ã¨ã‚ã‚‹ï¼‰
      const groupedContent = this.groupSimilarContent(rawData);

      for (const group of groupedContent) {
        try {
          // å“è³ªè©•ä¾¡
          const qualityScores = await Promise.all(
            group.map(content => evaluator.evaluate(content))
          );
          const avgQuality = qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length;

          if (avgQuality < 5) continue;

          // èˆˆå‘³åº¦è¨ˆç®—
          const user = await UserModel.findById(userId);
          if (!user) continue;

          const interestScores = await Promise.all(
            group.map(content =>
              interestCalculator.calculate(content, user.profile as any)
            )
          );
          const avgInterest = interestScores.reduce((a, b) => a + b, 0) / interestScores.length;

          if (avgInterest < 3) continue;

          // è¨˜äº‹ç”Ÿæˆ
          const article = await generator.generate(group, user.profile as any);

          const savedArticle = await ArticleModel.create({
            ...article,
            authorId: userId,
            interestScore: Math.round(avgInterest),
            qualityScore: Math.round(avgQuality)
          });

          generatedArticles.push(savedArticle);

        } catch (error) {
          logger.error('Failed to generate article from group', error as Error);
        }
      }

      // ã‚¸ãƒ§ãƒ–å®Œäº†
      await CollectionJobModel.complete(job.id, {
        articlesCreated: generatedArticles.length
      });

      allGeneratedArticles.push(...generatedArticles);
    }

    // é«˜å“è³ªè¨˜äº‹ã‚’é€šçŸ¥
    const highQualityArticles = allGeneratedArticles.filter(
      article => article.interestScore >= 7
    );

    if (highQualityArticles.length > 0) {
      await notificationService.notifyNewArticles(highQualityArticles);
    }

    logger.info('Generation cron completed', {
      totalGenerated: allGeneratedArticles.length,
      highQuality: highQualityArticles.length
    });

    return NextResponse.json({
      success: true,
      articlesGenerated: allGeneratedArticles.length
    });

  } catch (error) {
    logger.error('Generation cron failed', error as Error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

private groupSimilarContent(items: RawContentData[]): RawContentData[][] {
  // ç°¡æ˜“çš„ãªã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼ˆå®Ÿéš›ã¯ã‚ˆã‚Šé«˜åº¦ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ï¼‰
  const groups: RawContentData[][] = [];
  const used = new Set<number>();

  for (let i = 0; i < items.length; i++) {
    if (used.has(i)) continue;

    const group = [items[i]];
    used.add(i);

    // ã‚¿ã‚¤ãƒˆãƒ«ã®é¡ä¼¼åº¦ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    for (let j = i + 1; j < items.length; j++) {
      if (used.has(j)) continue;

      if (this.areSimilar(items[i], items[j])) {
        group.push(items[j]);
        used.add(j);
      }
    }

    groups.push(group);
  }

  return groups;
}

private areSimilar(a: RawContentData, b: RawContentData): boolean {
  // ç°¡æ˜“çš„ãªé¡ä¼¼åº¦åˆ¤å®šï¼ˆå®Ÿéš›ã¯ã‚ˆã‚Šé«˜åº¦ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ï¼‰
  const wordsA = new Set(a.title.toLowerCase().split(/\s+/));
  const wordsB = new Set(b.title.toLowerCase().split(/\s+/));

  const intersection = new Set([...wordsA].filter(x => wordsB.has(x)));
  const union = new Set([...wordsA, ...wordsB]);

  const jaccard = intersection.size / union.size;
  return jaccard > 0.3;
}

export const runtime = 'nodejs';
export const maxDuration = 300;
```

## 8. é€šçŸ¥ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…

```typescript
// src/lib/notifications/slack.ts
import axios from 'axios';
import type { Article } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';

export class NotificationService {
  private webhookUrl: string;
  private logger: Logger;

  constructor() {
    this.webhookUrl = process.env.SLACK_WEBHOOK_URL!;
    this.logger = new Logger('NotificationService');
  }

  async notifyNewArticles(articles: Article[]): Promise<void> {
    if (!this.webhookUrl) {
      this.logger.warn('Slack webhook URL not configured');
      return;
    }

    try {
      const message = this.buildSlackMessage(articles);

      await axios.post(this.webhookUrl, message);

      this.logger.info('Slack notification sent', {
        articleCount: articles.length,
      });
    } catch (error) {
      this.logger.error('Failed to send Slack notification', error as Error);
    }
  }

  private buildSlackMessage(articles: Article[]) {
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `ğŸ¤– æ–°ã—ã„è¨˜äº‹ãŒ${articles.length}ä»¶æŠ•ç¨¿ã•ã‚Œã¾ã—ãŸï¼`,
        },
      },
    ];

    articles.forEach((article, index) => {
      blocks.push(
        {
          type: 'divider',
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*${index + 1}. ${article.title}*\n${article.summary}`,
          },
          accessory: {
            type: 'button',
            text: {
              type: 'plain_text',
              text: 'è¨˜äº‹ã‚’èª­ã‚€',
            },
            url: `${process.env.NEXT_PUBLIC_APP_URL}/articles/${article.id}`,
            action_id: `view_article_${article.id}`,
          },
        },
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: `èˆˆå‘³åº¦: ${'â­'.repeat(Math.min(article.interestScore, 5))}`,
            },
            {
              type: 'mrkdwn',
              text: `ã‚«ãƒ†ã‚´ãƒª: ${article.category?.name || 'æœªåˆ†é¡'}`,
            },
          ],
        }
      );
    });

    return { blocks };
  }

  async notifyError(error: Error, context: Record<string, any>): Promise<void> {
    if (!this.webhookUrl) return;

    try {
      await axios.post(this.webhookUrl, {
        text: `âš ï¸ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ`,
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*ã‚¨ãƒ©ãƒ¼:* ${error.message}\n*ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ:* \`\`\`${JSON.stringify(context, null, 2)}\`\`\``,
            },
          },
        ],
      });
    } catch (notifyError) {
      this.logger.error('Failed to send error notification', notifyError as Error);
    }
  }
}
```

## 9. ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆè¨­å®š

### 9.1 Vercelè¨­å®š

```json
// vercel.json
{
  "framework": "nextjs",
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "regions": ["hnd1"],
  "functions": {
    "src/app/api/internal/collect/route.ts": {
      "maxDuration": 300
    },
    "src/app/api/internal/generate/route.ts": {
      "maxDuration": 300
    },
    "src/app/api/internal/cron/collect/route.ts": {
      "maxDuration": 300
    },
    "src/app/api/internal/cron/generate/route.ts": {
      "maxDuration": 300
    }
  },
  "crons": [
    {
      "path": "/api/internal/cron/collect",
      "schedule": "0 7 * * *"
    },
    {
      "path": "/api/internal/cron/generate",
      "schedule": "30 7 * * *"
    }
  ]
}
```

### 9.2 ç’°å¢ƒå¤‰æ•°

```bash
# .env.example
# Database
DATABASE_URL="postgres://user:password@host:5432/dbname"
DATABASE_URL_NON_POOLING="postgres://user:password@host:5432/dbname"

# Cache
KV_URL="redis://user:password@host:6379"
KV_REST_API_URL="https://..."
KV_REST_API_TOKEN="..."

# AI Services
OPENAI_API_KEY="sk-..."
ANTHROPIC_API_KEY="sk-ant-..."

# External APIs
GOOGLE_CUSTOM_SEARCH_API_KEY="..."
GOOGLE_SEARCH_ENGINE_ID="..."
NEWS_API_KEY="..."
REDDIT_CLIENT_ID="..."
REDDIT_CLIENT_SECRET="..."

# Notifications
SLACK_WEBHOOK_URL="https://hooks.slack.com/services/..."

# Security
INTERNAL_API_KEY="..."
CRON_SECRET="..."

# App
NEXT_PUBLIC_APP_URL="https://your-domain.com"
NODE_ENV="production"
```

## 10. ã¾ã¨ã‚

ã“ã®è©³ç´°è¨­è¨ˆæ›¸ã§ã¯ã€å€‹äººã‚­ãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚µã‚¤ãƒˆã®å®Ÿè£…ã«å¿…è¦ãªã™ã¹ã¦ã®æŠ€è¡“çš„è©³ç´°ã‚’ç¶²ç¾…ã—ã¾ã—ãŸã€‚

### ä¸»è¦ãªè¨­è¨ˆãƒã‚¤ãƒ³ãƒˆ

1. **ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼è¨­è¨ˆ**: å„æ©Ÿèƒ½ã‚’ç‹¬ç«‹ã—ãŸã‚µãƒ¼ãƒ“ã‚¹ã¨ã—ã¦å®Ÿè£…ã—ã€ä¿å®ˆæ€§ã¨æ‹¡å¼µæ€§ã‚’ç¢ºä¿
2. **å‹å®‰å…¨æ€§**: TypeScriptã¨Zodã‚’æ´»ç”¨ã—ãŸå³å¯†ãªå‹å®šç¾©
3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: å¤šå±¤ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã¨SSG/ISRã®æ´»ç”¨
4. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**: åŒ…æ‹¬çš„ãªã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨é€šçŸ¥æ©Ÿèƒ½
5. **è‡ªå‹•åŒ–**: Cron Jobã«ã‚ˆã‚‹å®Œå…¨è‡ªå‹•åŒ–

### æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

1. é–‹ç™ºç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒã®å®Ÿè£…
3. åŸºæœ¬çš„ãªCRUDæ©Ÿèƒ½ã®å®Ÿè£…
4. AIçµ±åˆã®å®Ÿè£…ã¨ãƒ†ã‚¹ãƒˆ
5. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®å®Ÿè£…
6. ãƒ‡ãƒ—ãƒ­ã‚¤ã¨å‹•ä½œç¢ºèª

ã“ã®è¨­è¨ˆã«åŸºã¥ã„ã¦å®Ÿè£…ã‚’é€²ã‚ã‚‹ã“ã¨ã§ã€è¦ä»¶ã‚’æº€ãŸã™é«˜å“è³ªãªã‚­ãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚µã‚¤ãƒˆã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚
