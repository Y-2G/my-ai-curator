# 個人キュレーションサイト 詳細設計書

## 1. ディレクトリ構造

```
smart-curator/
├── src/
│   ├── app/                          # Next.js App Router
│   │   ├── (main)/                   # メインレイアウトグループ
│   │   │   ├── layout.tsx
│   │   │   ├── page.tsx              # ホームページ
│   │   │   ├── articles/
│   │   │   │   ├── page.tsx          # 記事一覧
│   │   │   │   ├── [id]/
│   │   │   │   │   └── page.tsx      # 記事詳細
│   │   │   │   └── category/
│   │   │   │       └── [category]/
│   │   │   │           └── page.tsx   # カテゴリ別記事
│   │   │   ├── search/
│   │   │   │   └── page.tsx          # 検索ページ
│   │   │   └── tags/
│   │   │       └── [tag]/
│   │   │           └── page.tsx       # タグ別記事
│   │   ├── api/
│   │   │   ├── articles/
│   │   │   │   ├── route.ts          # GET: 記事一覧
│   │   │   │   └── [id]/
│   │   │   │       └── route.ts      # GET: 記事詳細
│   │   │   ├── categories/
│   │   │   │   └── route.ts          # GET: カテゴリ一覧
│   │   │   ├── tags/
│   │   │   │   └── route.ts          # GET: タグ一覧
│   │   │   └── internal/             # 内部API（認証必須）
│   │   │       ├── collect/
│   │   │       │   └── route.ts      # POST: 情報収集実行
│   │   │       ├── generate/
│   │   │       │   └── route.ts      # POST: 記事生成実行
│   │   │       ├── cron/
│   │   │       │   ├── collect/
│   │   │       │   │   └── route.ts  # Cron: 定期収集
│   │   │       │   └── generate/
│   │   │       │       └── route.ts  # Cron: 定期生成
│   │   │       └── jobs/
│   │   │           └── [id]/
│   │   │               └── route.ts  # GET: ジョブ状況確認
│   │   ├── favicon.ico
│   │   └── globals.css
│   ├── components/
│   │   ├── ui/                       # 基本UIコンポーネント
│   │   │   ├── Button.tsx
│   │   │   ├── Card.tsx
│   │   │   ├── Input.tsx
│   │   │   ├── Badge.tsx
│   │   │   ├── Skeleton.tsx
│   │   │   └── Modal.tsx
│   │   ├── layout/
│   │   │   ├── Header.tsx
│   │   │   ├── Footer.tsx
│   │   │   ├── Sidebar.tsx
│   │   │   └── Navigation.tsx
│   │   ├── article/
│   │   │   ├── ArticleCard.tsx
│   │   │   ├── ArticleList.tsx
│   │   │   ├── ArticleDetail.tsx
│   │   │   ├── ArticleSearch.tsx
│   │   │   ├── CategoryBadge.tsx
│   │   │   ├── TagList.tsx
│   │   │   └── InterestScore.tsx
│   │   └── common/
│   │       ├── Loading.tsx
│   │       ├── ErrorBoundary.tsx
│   │       ├── Pagination.tsx
│   │       └── SEO.tsx
│   ├── lib/
│   │   ├── api/                      # APIクライアント
│   │   │   ├── client.ts             # HTTPクライアント設定
│   │   │   ├── articles.ts
│   │   │   ├── categories.ts
│   │   │   └── internal.ts
│   │   ├── db/                       # データベース関連
│   │   │   ├── prisma.ts             # Prismaクライアント
│   │   │   ├── models/
│   │   │   │   ├── article.ts
│   │   │   │   ├── category.ts
│   │   │   │   ├── tag.ts
│   │   │   │   ├── source.ts
│   │   │   │   └── user.ts
│   │   │   └── migrations/
│   │   ├── ai/                       # AIサービス
│   │   │   ├── client.ts             # AI APIクライアント
│   │   │   ├── prompts/
│   │   │   │   ├── search-query.ts
│   │   │   │   ├── article-generation.ts
│   │   │   │   ├── categorization.ts
│   │   │   │   └── quality-evaluation.ts
│   │   │   ├── services/
│   │   │   │   ├── article-generator.ts
│   │   │   │   ├── content-evaluator.ts
│   │   │   │   └── interest-calculator.ts
│   │   │   └── types.ts
│   │   ├── collectors/               # 情報収集サービス
│   │   │   ├── base.ts               # 基底クラス
│   │   │   ├── google-search.ts
│   │   │   ├── news-api.ts
│   │   │   ├── reddit.ts
│   │   │   ├── github.ts
│   │   │   ├── rss-parser.ts
│   │   │   └── index.ts
│   │   ├── notifications/            # 通知サービス
│   │   │   ├── slack.ts
│   │   │   └── types.ts
│   │   ├── utils/                    # ユーティリティ
│   │   │   ├── date.ts
│   │   │   ├── string.ts
│   │   │   ├── validation.ts
│   │   │   ├── logger.ts
│   │   │   └── error-handler.ts
│   │   ├── cache/                    # キャッシュ管理
│   │   │   ├── redis.ts
│   │   │   └── strategies.ts
│   │   ├── types/                    # 型定義
│   │   │   ├── article.ts
│   │   │   ├── api.ts
│   │   │   ├── database.ts
│   │   │   └── index.ts
│   │   └── constants/                # 定数
│   │       ├── api.ts
│   │       ├── config.ts
│   │       └── ui.ts
│   ├── hooks/                        # カスタムフック
│   │   ├── useArticles.ts
│   │   ├── useCategories.ts
│   │   ├── useSearch.ts
│   │   ├── usePagination.ts
│   │   └── useDebounce.ts
│   └── middleware.ts                 # Next.jsミドルウェア
├── prisma/
│   ├── schema.prisma                 # Prismaスキーマ
│   └── seed.ts                       # シードデータ
├── public/
│   ├── images/
│   └── robots.txt
├── tests/
│   ├── unit/
│   ├── integration/
│   └── e2e/
├── .env.example
├── .gitignore
├── next.config.ts
├── package.json
├── tsconfig.json
├── tailwind.config.ts
└── README.md
```

## 2. データベース詳細設計

### 2.1 Prisma Schema

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String    @id @default(uuid())
  email      String    @unique
  name       String
  profile    Json      @default("{}")
  interests  Json      @default("{}")
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  articles   Article[]
  userInterests UserInterest[]

  @@index([email])
}

model Category {
  id          String    @id @default(uuid())
  name        String    @unique
  description String?
  color       String    @default("#000000")
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  articles    Article[]

  @@index([name])
}

model Article {
  id            String    @id @default(uuid())
  title         String
  summary       String
  content       String    @db.Text
  categoryId    String?
  authorId      String?
  interestScore Int       @default(0)
  qualityScore  Int       @default(0)
  publishedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  category      Category? @relation(fields: [categoryId], references: [id])
  author        User?     @relation(fields: [authorId], references: [id])
  sources       Source[]
  articleTags   ArticleTag[]

  @@index([publishedAt(sort: Desc)])
  @@index([categoryId])
  @@index([interestScore(sort: Desc)])
  @@index([createdAt(sort: Desc)])
}

model Source {
  id        String   @id @default(uuid())
  articleId String
  url       String
  title     String?
  type      String   // 'google', 'news', 'reddit', 'github', 'rss'
  createdAt DateTime @default(now())

  article   Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@index([articleId])
  @@index([type])
}

model Tag {
  id          String   @id @default(uuid())
  name        String   @unique
  createdAt   DateTime @default(now())

  articleTags ArticleTag[]

  @@index([name])
}

model ArticleTag {
  id        String   @id @default(uuid())
  articleId String
  tagId     String
  createdAt DateTime @default(now())

  article   Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  tag       Tag      @relation(fields: [tagId], references: [id])

  @@unique([articleId, tagId])
  @@index([articleId])
  @@index([tagId])
}

model CollectionJob {
  id              String    @id @default(uuid())
  status          String    @default("pending") // 'pending', 'running', 'completed', 'failed'
  startedAt       DateTime?
  completedAt     DateTime?
  errorMessage    String?
  articlesCreated Int       @default(0)
  metadata        Json?
  createdAt       DateTime  @default(now())

  @@index([status])
  @@index([createdAt(sort: Desc)])
}

model UserInterest {
  id        String   @id @default(uuid())
  userId    String
  keyword   String
  weight    Float    @default(1.0)
  lastUsed  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, keyword])
  @@index([userId])
  @@index([weight(sort: Desc)])
}
```

### 2.2 データアクセス層実装

```typescript
// src/lib/db/models/article.ts
import { prisma } from '@/lib/db/prisma';
import type { Article, Prisma } from '@prisma/client';

export interface ArticleWithRelations extends Article {
  category: Category | null;
  sources: Source[];
  articleTags: (ArticleTag & { tag: Tag })[];
}

export interface ArticleListParams {
  page?: number;
  limit?: number;
  categoryId?: string;
  tagId?: string;
  sort?: 'createdAt' | 'interestScore' | 'qualityScore';
  order?: 'asc' | 'desc';
}

export class ArticleModel {
  static async findMany(params: ArticleListParams): Promise<{
    articles: ArticleWithRelations[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20, categoryId, tagId, sort = 'createdAt', order = 'desc' } = params;

    const where: Prisma.ArticleWhereInput = {
      publishedAt: { not: null },
    };

    if (categoryId) {
      where.categoryId = categoryId;
    }

    if (tagId) {
      where.articleTags = {
        some: { tagId },
      };
    }

    const [articles, total] = await Promise.all([
      prisma.article.findMany({
        where,
        include: {
          category: true,
          sources: true,
          articleTags: {
            include: { tag: true },
          },
        },
        orderBy: { [sort]: order },
        skip: (page - 1) * limit,
        take: limit,
      }),
      prisma.article.count({ where }),
    ]);

    return {
      articles,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  static async findById(id: string): Promise<ArticleWithRelations | null> {
    return prisma.article.findUnique({
      where: { id },
      include: {
        category: true,
        sources: true,
        articleTags: {
          include: { tag: true },
        },
      },
    });
  }

  static async create(data: {
    title: string;
    summary: string;
    content: string;
    categoryId?: string;
    authorId?: string;
    sources: { url: string; title?: string; type: string }[];
    tags: string[];
    interestScore: number;
    qualityScore: number;
  }): Promise<ArticleWithRelations> {
    const { sources, tags, ...articleData } = data;

    return prisma.$transaction(async (tx) => {
      // 記事作成
      const article = await tx.article.create({
        data: {
          ...articleData,
          publishedAt: new Date(),
        },
      });

      // ソース作成
      if (sources.length > 0) {
        await tx.source.createMany({
          data: sources.map((source) => ({
            ...source,
            articleId: article.id,
          })),
        });
      }

      // タグ処理
      if (tags.length > 0) {
        // 既存タグ取得または作成
        const tagRecords = await Promise.all(
          tags.map(async (tagName) => {
            return tx.tag.upsert({
              where: { name: tagName },
              update: {},
              create: { name: tagName },
            });
          })
        );

        // ArticleTag作成
        await tx.articleTag.createMany({
          data: tagRecords.map((tag) => ({
            articleId: article.id,
            tagId: tag.id,
          })),
        });
      }

      // 完全なデータを再取得
      return tx.article.findUnique({
        where: { id: article.id },
        include: {
          category: true,
          sources: true,
          articleTags: {
            include: { tag: true },
          },
        },
      }) as Promise<ArticleWithRelations>;
    });
  }

  static async updateInterestScore(id: string, score: number): Promise<void> {
    await prisma.article.update({
      where: { id },
      data: { interestScore: score },
    });
  }
}
```

## 3. API実装詳細

### 3.1 記事一覧API

```typescript
// src/app/api/articles/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { ArticleModel } from '@/lib/db/models/article';
import { withErrorHandler } from '@/lib/utils/error-handler';
import { cacheStrategy } from '@/lib/cache/strategies';

const querySchema = z.object({
  page: z.coerce.number().min(1).optional(),
  limit: z.coerce.number().min(1).max(100).optional(),
  category: z.string().uuid().optional(),
  tag: z.string().uuid().optional(),
  sort: z.enum(['createdAt', 'interestScore', 'qualityScore']).optional(),
  order: z.enum(['asc', 'desc']).optional(),
});

export async function GET(request: NextRequest) {
  return withErrorHandler(async () => {
    const searchParams = Object.fromEntries(request.nextUrl.searchParams);
    const query = querySchema.parse(searchParams);

    // キャッシュチェック
    const cacheKey = `articles:${JSON.stringify(query)}`;
    const cached = await cacheStrategy.get(cacheKey);
    if (cached) {
      return NextResponse.json(cached);
    }

    const result = await ArticleModel.findMany({
      page: query.page,
      limit: query.limit,
      categoryId: query.category,
      tagId: query.tag,
      sort: query.sort,
      order: query.order,
    });

    // レスポンス形式変換
    const response = {
      articles: result.articles.map((article) => ({
        id: article.id,
        title: article.title,
        summary: article.summary,
        category: article.category
          ? {
              id: article.category.id,
              name: article.category.name,
              color: article.category.color,
            }
          : null,
        tags: article.articleTags.map((at) => ({
          id: at.tag.id,
          name: at.tag.name,
        })),
        interestScore: article.interestScore,
        qualityScore: article.qualityScore,
        publishedAt: article.publishedAt?.toISOString(),
        createdAt: article.createdAt.toISOString(),
      })),
      pagination: {
        page: result.page,
        limit: query.limit || 20,
        total: result.total,
        totalPages: result.totalPages,
      },
    };

    // キャッシュ保存（15分）
    await cacheStrategy.set(cacheKey, response, 900);

    return NextResponse.json(response);
  });
}
```

### 3.2 情報収集API

```typescript
// src/app/api/internal/collect/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { verifyInternalApiKey } from '@/lib/auth/middleware';
import { CollectorManager } from '@/lib/collectors';
import { CollectionJobModel } from '@/lib/db/models/collection-job';
import { withErrorHandler } from '@/lib/utils/error-handler';
import { Logger } from '@/lib/utils/logger';

const requestSchema = z.object({
  sources: z.array(z.enum(['google', 'news', 'reddit', 'github', 'rss'])),
  limit: z.number().min(1).max(100).default(20),
});

export async function POST(request: NextRequest) {
  // 内部API認証
  const authResult = await verifyInternalApiKey(request);
  if (!authResult.valid) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  return withErrorHandler(async () => {
    const body = await request.json();
    const { sources, limit } = requestSchema.parse(body);

    // ジョブ作成
    const job = await CollectionJobModel.create();

    // 非同期で収集開始
    collectAsync(job.id, sources, limit);

    return NextResponse.json({
      jobId: job.id,
      status: 'started',
      message: 'Collection job started',
    });
  });
}

async function collectAsync(jobId: string, sources: string[], limit: number): Promise<void> {
  const logger = new Logger('CollectionJob');

  try {
    await CollectionJobModel.updateStatus(jobId, 'running');

    const collectorManager = new CollectorManager();
    const results = await collectorManager.collectFromMultipleSources(sources, limit);

    logger.info(`Collected ${results.length} items from ${sources.join(', ')}`, {
      jobId,
      sources,
      resultCount: results.length,
    });

    await CollectionJobModel.complete(jobId, {
      articlesCreated: 0, // 記事生成前なので0
      metadata: {
        sources,
        collectedItems: results.length,
        timestamp: new Date().toISOString(),
      },
    });

    // 収集データを一時保存（後続の生成処理で使用）
    await cacheStrategy.set(
      `collection:${jobId}`,
      results,
      3600 // 1時間保持
    );
  } catch (error) {
    logger.error('Collection job failed', error as Error, { jobId });
    await CollectionJobModel.fail(jobId, error instanceof Error ? error.message : 'Unknown error');
  }
}
```

### 3.3 記事生成API

```typescript
// src/app/api/internal/generate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { verifyInternalApiKey } from '@/lib/auth/middleware';
import { ArticleGenerator } from '@/lib/ai/services/article-generator';
import { ContentEvaluator } from '@/lib/ai/services/content-evaluator';
import { InterestCalculator } from '@/lib/ai/services/interest-calculator';
import { ArticleModel } from '@/lib/db/models/article';
import { UserModel } from '@/lib/db/models/user';
import { NotificationService } from '@/lib/notifications/slack';
import { withErrorHandler } from '@/lib/utils/error-handler';
import { Logger } from '@/lib/utils/logger';

const requestSchema = z.object({
  jobId: z.string().optional(),
  userId: z.string().uuid(),
  rawData: z
    .array(
      z.object({
        title: z.string(),
        url: z.string(),
        summary: z.string(),
        publishedAt: z.string(),
        source: z.string(),
        type: z.string(),
        metadata: z.record(z.any()),
      })
    )
    .optional(),
});

export async function POST(request: NextRequest) {
  const authResult = await verifyInternalApiKey(request);
  if (!authResult.valid) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  return withErrorHandler(async () => {
    const body = await request.json();
    const { jobId, userId, rawData: providedData } = requestSchema.parse(body);

    // データ取得（キャッシュまたはリクエストボディから）
    let rawData = providedData;
    if (!rawData && jobId) {
      rawData = await cacheStrategy.get(`collection:${jobId}`);
      if (!rawData) {
        return NextResponse.json({ error: 'Collection data not found' }, { status: 404 });
      }
    }

    if (!rawData || rawData.length === 0) {
      return NextResponse.json({ error: 'No data to generate articles from' }, { status: 400 });
    }

    // ユーザー情報取得
    const user = await UserModel.findById(userId);
    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    const logger = new Logger('ArticleGeneration');
    const generator = new ArticleGenerator();
    const evaluator = new ContentEvaluator();
    const interestCalculator = new InterestCalculator();
    const notificationService = new NotificationService();

    const generatedArticles = [];

    // 各コンテンツを評価・処理
    for (const content of rawData) {
      try {
        // 品質評価
        const qualityScore = await evaluator.evaluate(content);
        if (qualityScore < 5) {
          logger.info('Content quality too low, skipping', {
            url: content.url,
            qualityScore,
          });
          continue;
        }

        // 興味度計算
        const interestScore = await interestCalculator.calculate(content, user.profile as any);
        if (interestScore < 3) {
          logger.info('Content interest too low, skipping', {
            url: content.url,
            interestScore,
          });
          continue;
        }

        // 記事生成
        const article = await generator.generate([content], user.profile as any);

        // データベース保存
        const savedArticle = await ArticleModel.create({
          ...article,
          authorId: userId,
          interestScore,
          qualityScore,
        });

        generatedArticles.push(savedArticle);

        logger.info('Article generated successfully', {
          articleId: savedArticle.id,
          title: savedArticle.title,
        });
      } catch (error) {
        logger.error('Failed to generate article', error as Error, {
          url: content.url,
        });
      }
    }

    // 高品質記事のみ通知
    const highQualityArticles = generatedArticles.filter((article) => article.interestScore >= 7);

    if (highQualityArticles.length > 0) {
      await notificationService.notifyNewArticles(highQualityArticles);
    }

    return NextResponse.json({
      success: true,
      articlesGenerated: generatedArticles.length,
      articles: generatedArticles.map((article) => ({
        id: article.id,
        title: article.title,
        interestScore: article.interestScore,
        qualityScore: article.qualityScore,
      })),
    });
  });
}
```

## 4. AI処理実装

### 4.1 記事生成サービス

```typescript
// src/lib/ai/services/article-generator.ts
import { OpenAI } from 'openai';
import { z } from 'zod';
import { ARTICLE_GENERATION_PROMPT } from '@/lib/ai/prompts/article-generation';
import type { RawContentData, GeneratedArticle } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';

const generatedArticleSchema = z.object({
  title: z.string(),
  summary: z.string(),
  content: z.string(),
  category: z.string(),
  tags: z.array(z.string()),
  confidence: z.number(),
});

export class ArticleGenerator {
  private openai: OpenAI;
  private logger: Logger;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    this.logger = new Logger('ArticleGenerator');
  }

  async generate(
    sources: RawContentData[],
    userProfile: {
      techLevel: string;
      interests: string[];
      preferredStyle: string;
    }
  ): Promise<GeneratedArticle> {
    const prompt = this.buildPrompt(sources, userProfile);

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content:
              'あなたは技術系ブログのライターです。提供された情報から魅力的な記事を作成してください。',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.7,
        response_format: { type: 'json_object' },
      });

      const content = response.choices[0].message.content;
      if (!content) {
        throw new Error('No content generated');
      }

      const parsed = JSON.parse(content);
      const validated = generatedArticleSchema.parse(parsed);

      return {
        ...validated,
        sources: sources.map((s) => ({
          url: s.url,
          title: s.title,
          type: s.type,
        })),
      };
    } catch (error) {
      this.logger.error('Failed to generate article', error as Error);
      throw error;
    }
  }

  private buildPrompt(
    sources: RawContentData[],
    userProfile: {
      techLevel: string;
      interests: string[];
      preferredStyle: string;
    }
  ): string {
    const sourcesText = sources
      .map((s) => `- ${s.title}\n  URL: ${s.url}\n  要約: ${s.summary}`)
      .join('\n\n');

    return ARTICLE_GENERATION_PROMPT.replace('{{user.techLevel}}', userProfile.techLevel)
      .replace('{{user.interests}}', userProfile.interests.join(', '))
      .replace('{{user.preferredStyle}}', userProfile.preferredStyle)
      .replace('{{sources}}', sourcesText);
  }
}
```

### 4.2 興味度計算サービス

```typescript
// src/lib/ai/services/interest-calculator.ts
import { OpenAI } from 'openai';
import type { RawContentData } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';

export class InterestCalculator {
  private openai: OpenAI;
  private logger: Logger;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    this.logger = new Logger('InterestCalculator');
  }

  async calculate(
    content: RawContentData,
    userProfile: {
      interests: string[];
      recentTopics: string[];
      techLevel: string;
    }
  ): Promise<number> {
    const prompt = `
以下のコンテンツが、指定されたユーザープロフィールにどの程度興味深いかを1-10のスコアで評価してください。

# ユーザープロフィール
- 興味分野: ${userProfile.interests.join(', ')}
- 最近の関心事: ${userProfile.recentTopics.join(', ')}
- 技術レベル: ${userProfile.techLevel}

# コンテンツ
タイトル: ${content.title}
要約: ${content.summary}
ソース: ${content.source}

# 評価基準
- 興味分野との関連性（40%）
- 新規性・トレンド性（30%）
- 技術レベルの適合性（20%）
- 実用性（10%）

スコアのみを数値で回答してください。
`;

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.3,
        max_tokens: 10,
      });

      const scoreText = response.choices[0].message.content?.trim();
      const score = parseInt(scoreText || '0', 10);

      if (isNaN(score) || score < 1 || score > 10) {
        this.logger.warn('Invalid interest score', { scoreText });
        return 5; // デフォルト値
      }

      return score;
    } catch (error) {
      this.logger.error('Failed to calculate interest score', error as Error);
      return 5; // エラー時のデフォルト値
    }
  }
}
```

## 5. 情報収集実装

### 5.1 収集サービス基底クラス

```typescript
// src/lib/collectors/base.ts
import type { RawContentData } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';
import { RateLimiter } from '@/lib/utils/rate-limiter';

export abstract class BaseCollector {
  protected logger: Logger;
  protected rateLimiter: RateLimiter;

  constructor(protected name: string) {
    this.logger = new Logger(`Collector:${name}`);
    this.rateLimiter = new RateLimiter();
  }

  abstract collect(query: string, limit: number): Promise<RawContentData[]>;

  async isRateLimited(): Promise<boolean> {
    return this.rateLimiter.isLimited(`collector:${this.name}`);
  }

  async getNextAvailableTime(): Promise<Date | null> {
    return this.rateLimiter.getNextAvailableTime(`collector:${this.name}`);
  }

  protected async trackApiCall(): Promise<void> {
    await this.rateLimiter.track(`collector:${this.name}`);
  }

  protected transformToRawContent(data: any): RawContentData {
    // 各収集サービスでオーバーライド
    throw new Error('transformToRawContent must be implemented');
  }
}
```

### 5.2 Google検索収集サービス

```typescript
// src/lib/collectors/google-search.ts
import axios from 'axios';
import { BaseCollector } from './base';
import type { RawContentData } from '@/lib/types';

interface GoogleSearchResult {
  title: string;
  link: string;
  snippet: string;
  pagemap?: {
    metatags?: Array<{
      'og:description'?: string;
      'article:published_time'?: string;
    }>;
  };
}

export class GoogleSearchCollector extends BaseCollector {
  private apiKey: string;
  private searchEngineId: string;

  constructor() {
    super('GoogleSearch');
    this.apiKey = process.env.GOOGLE_CUSTOM_SEARCH_API_KEY!;
    this.searchEngineId = process.env.GOOGLE_SEARCH_ENGINE_ID!;
  }

  async collect(query: string, limit: number): Promise<RawContentData[]> {
    await this.trackApiCall();

    try {
      const response = await axios.get('https://www.googleapis.com/customsearch/v1', {
        params: {
          key: this.apiKey,
          cx: this.searchEngineId,
          q: query,
          num: Math.min(limit, 10), // Google APIは最大10件
          sort: 'date',
        },
      });

      const items = response.data.items || [];

      return items.map((item: GoogleSearchResult) => this.transformToRawContent(item));
    } catch (error) {
      this.logger.error('Failed to collect from Google', error as Error);
      return [];
    }
  }

  protected transformToRawContent(item: GoogleSearchResult): RawContentData {
    const publishedAt =
      item.pagemap?.metatags?.[0]?.['article:published_time'] || new Date().toISOString();

    return {
      title: item.title,
      url: item.link,
      summary: item.snippet,
      publishedAt,
      source: 'Google Search',
      type: 'google',
      metadata: {
        pagemap: item.pagemap,
      },
    };
  }
}
```

### 5.3 収集マネージャー

```typescript
// src/lib/collectors/index.ts
import { GoogleSearchCollector } from './google-search';
import { NewsApiCollector } from './news-api';
import { RedditCollector } from './reddit';
import { GitHubCollector } from './github';
import { RssCollector } from './rss-parser';
import type { RawContentData } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';

export class CollectorManager {
  private collectors: Map<string, BaseCollector>;
  private logger: Logger;

  constructor() {
    this.logger = new Logger('CollectorManager');
    this.collectors = new Map([
      ['google', new GoogleSearchCollector()],
      ['news', new NewsApiCollector()],
      ['reddit', new RedditCollector()],
      ['github', new GitHubCollector()],
      ['rss', new RssCollector()],
    ]);
  }

  async collectFromMultipleSources(
    sources: string[],
    limitPerSource: number
  ): Promise<RawContentData[]> {
    const results: RawContentData[] = [];
    const errors: Array<{ source: string; error: string }> = [];

    // 並列収集
    const promises = sources.map(async (source) => {
      const collector = this.collectors.get(source);
      if (!collector) {
        errors.push({ source, error: 'Collector not found' });
        return [];
      }

      try {
        // レート制限チェック
        if (await collector.isRateLimited()) {
          const nextTime = await collector.getNextAvailableTime();
          this.logger.warn(`${source} is rate limited`, { nextTime });
          return [];
        }

        // AI生成の検索クエリ
        const queries = await this.generateSearchQueries(source);
        const allResults: RawContentData[] = [];

        for (const query of queries) {
          const items = await collector.collect(query, limitPerSource);
          allResults.push(...items);
        }

        return allResults;
      } catch (error) {
        errors.push({
          source,
          error: error instanceof Error ? error.message : 'Unknown error',
        });
        return [];
      }
    });

    const sourceResults = await Promise.all(promises);
    sourceResults.forEach((items) => results.push(...items));

    // 重複除去
    const uniqueResults = this.removeDuplicates(results);

    this.logger.info('Collection completed', {
      totalCollected: uniqueResults.length,
      sources,
      errors,
    });

    return uniqueResults;
  }

  private async generateSearchQueries(source: string): Promise<string[]> {
    // TODO: AI サービスを使用してユーザープロフィールに基づいた検索クエリを生成
    // 仮実装
    const baseQueries = [
      'Next.js 15 new features',
      'TypeScript best practices 2024',
      'AI development tools',
      'web performance optimization',
    ];

    // ソースごとに最適化
    switch (source) {
      case 'reddit':
        return baseQueries.map((q) => `${q} site:reddit.com`);
      case 'github':
        return ['trending repositories', 'new releases'];
      default:
        return baseQueries;
    }
  }

  private removeDuplicates(items: RawContentData[]): RawContentData[] {
    const seen = new Set<string>();
    return items.filter((item) => {
      const key = item.url;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }
}
```

## 6. フロントエンド実装

### 6.1 記事一覧ページ

```tsx
// src/app/(main)/articles/page.tsx
import { Suspense } from 'react';
import { ArticleList } from '@/components/article/ArticleList';
import { CategoryFilter } from '@/components/article/CategoryFilter';
import { SearchBar } from '@/components/common/SearchBar';
import { Loading } from '@/components/common/Loading';
import { getArticles, getCategories } from '@/lib/api/server';

interface PageProps {
  searchParams: {
    page?: string;
    category?: string;
    search?: string;
  };
}

export default async function ArticlesPage({ searchParams }: PageProps) {
  const page = parseInt(searchParams.page || '1', 10);
  const categoryId = searchParams.category;
  const search = searchParams.search;

  const [articlesData, categories] = await Promise.all([
    getArticles({ page, categoryId, search }),
    getCategories(),
  ]);

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">記事一覧</h1>

      <div className="mb-6 space-y-4">
        <SearchBar defaultValue={search} />
        <CategoryFilter categories={categories} selectedCategoryId={categoryId} />
      </div>

      <Suspense fallback={<Loading />}>
        <ArticleList articles={articlesData.articles} pagination={articlesData.pagination} />
      </Suspense>
    </div>
  );
}

export async function generateMetadata({ searchParams }: PageProps) {
  const page = searchParams.page || '1';

  return {
    title: `記事一覧 - ページ ${page}`,
    description: 'AIがキュレーションした最新記事一覧',
  };
}
```

### 6.2 記事詳細ページ

```tsx
// src/app/(main)/articles/[id]/page.tsx
import { notFound } from 'next/navigation';
import { ArticleDetail } from '@/components/article/ArticleDetail';
import { RelatedArticles } from '@/components/article/RelatedArticles';
import { getArticleById, getRelatedArticles } from '@/lib/api/server';

interface PageProps {
  params: {
    id: string;
  };
}

export default async function ArticlePage({ params }: PageProps) {
  const article = await getArticleById(params.id);

  if (!article) {
    notFound();
  }

  const relatedArticles = await getRelatedArticles(params.id);

  return (
    <div className="container mx-auto px-4 py-8">
      <ArticleDetail article={article} />

      {relatedArticles.length > 0 && (
        <div className="mt-12">
          <h2 className="text-2xl font-bold mb-6">関連記事</h2>
          <RelatedArticles articles={relatedArticles} />
        </div>
      )}
    </div>
  );
}

export async function generateMetadata({ params }: PageProps) {
  const article = await getArticleById(params.id);

  if (!article) {
    return {
      title: '記事が見つかりません',
    };
  }

  return {
    title: article.title,
    description: article.summary,
    openGraph: {
      title: article.title,
      description: article.summary,
      type: 'article',
      publishedTime: article.publishedAt,
      authors: ['AI Curator'],
      tags: article.tags.map((t) => t.name),
    },
  };
}

export async function generateStaticParams() {
  // 最新50記事をSSG対象とする
  const articles = await getRecentArticles(50);

  return articles.map((article) => ({
    id: article.id,
  }));
}
```

### 6.3 記事カードコンポーネント

```tsx
// src/components/article/ArticleCard.tsx
'use client';

import Link from 'next/link';
import { formatDistanceToNow } from 'date-fns';
import { ja } from 'date-fns/locale';
import { CategoryBadge } from './CategoryBadge';
import { TagList } from './TagList';
import { InterestScore } from './InterestScore';
import { Card } from '@/components/ui/Card';
import type { Article } from '@/lib/types';

interface ArticleCardProps {
  article: Article;
  variant?: 'default' | 'featured' | 'compact';
}

export function ArticleCard({ article, variant = 'default' }: ArticleCardProps) {
  const isCompact = variant === 'compact';
  const isFeatured = variant === 'featured';

  return (
    <Card
      className={`
        hover:shadow-lg transition-shadow duration-200
        ${isFeatured ? 'border-2 border-blue-500' : ''}
      `}
      padding={isCompact ? 'sm' : 'md'}
    >
      <article>
        <div className="flex items-start justify-between mb-3">
          {article.category && <CategoryBadge category={article.category} />}
          <InterestScore score={article.interestScore} />
        </div>

        <h3
          className={`
          font-semibold mb-2 line-clamp-2
          ${isCompact ? 'text-lg' : 'text-xl'}
        `}
        >
          <Link href={`/articles/${article.id}`} className="hover:text-blue-600 transition-colors">
            {article.title}
          </Link>
        </h3>

        {!isCompact && <p className="text-gray-600 mb-3 line-clamp-3">{article.summary}</p>}

        <div className="flex items-center justify-between text-sm text-gray-500">
          <TagList tags={article.tags} limit={isCompact ? 2 : 3} />
          <time
            dateTime={article.publishedAt}
            title={new Date(article.publishedAt).toLocaleString('ja-JP')}
          >
            {formatDistanceToNow(new Date(article.publishedAt), {
              addSuffix: true,
              locale: ja,
            })}
          </time>
        </div>
      </article>
    </Card>
  );
}
```

## 7. Cron Job実装

### 7.1 定期収集Cron

```typescript
// src/app/api/internal/cron/collect/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyVercelCron } from '@/lib/auth/cron';
import { CollectorManager } from '@/lib/collectors';
import { CollectionJobModel } from '@/lib/db/models/collection-job';
import { UserModel } from '@/lib/db/models/user';
import { cacheStrategy } from '@/lib/cache/strategies';
import { Logger } from '@/lib/utils/logger';

export async function GET(request: NextRequest) {
  // Vercel Cron認証
  const isValid = await verifyVercelCron(request);
  if (!isValid) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const logger = new Logger('CronCollect');

  try {
    // アクティブユーザー取得
    const users = await UserModel.findActiveUsers();
    logger.info(`Starting collection for ${users.length} users`);

    const collectorManager = new CollectorManager();
    const allResults = [];

    // 各ユーザーごとに収集
    for (const user of users) {
      const job = await CollectionJobModel.create({
        metadata: { userId: user.id },
      });

      try {
        await CollectionJobModel.updateStatus(job.id, 'running');

        // ユーザーの興味に基づいて収集
        const sources = ['google', 'news', 'reddit', 'github'];
        const results = await collectorManager.collectFromMultipleSources(
          sources,
          10 // 各ソースから10件
        );

        // 結果をキャッシュ
        await cacheStrategy.set(`collection:${job.id}`, results, 3600);

        await CollectionJobModel.complete(job.id, {
          articlesCreated: 0,
          metadata: {
            userId: user.id,
            collectedItems: results.length,
            sources,
          },
        });

        allResults.push({
          userId: user.id,
          jobId: job.id,
          itemsCollected: results.length,
        });
      } catch (error) {
        logger.error(`Collection failed for user ${user.id}`, error as Error);
        await CollectionJobModel.fail(
          job.id,
          error instanceof Error ? error.message : 'Unknown error'
        );
      }
    }

    logger.info('Collection cron completed', { results: allResults });

    return NextResponse.json({
      success: true,
      results: allResults,
    });
  } catch (error) {
    logger.error('Collection cron failed', error as Error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export const runtime = 'nodejs';
export const maxDuration = 300; // 5分
```

### 7.2 定期生成Cron

```typescript
// src/app/api/internal/cron/generate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { verifyVercelCron } from '@/lib/auth/cron';
import { ArticleGenerator } from '@/lib/ai/services/article-generator';
import { ContentEvaluator } from '@/lib/ai/services/content-evaluator';
import { InterestCalculator } from '@/lib/ai/services/interest-calculator';
import { ArticleModel } from '@/lib/db/models/article';
import { CollectionJobModel } from '@/lib/db/models/collection-job';
import { NotificationService } from '@/lib/notifications/slack';
import { cacheStrategy } from '@/lib/cache/strategies';
import { Logger } from '@/lib/utils/logger';

export async function GET(request: NextRequest) {
  const isValid = await verifyVercelCron(request);
  if (!isValid) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const logger = new Logger('CronGenerate');

  try {
    // 未処理の収集ジョブを取得
    const pendingJobs = await CollectionJobModel.findPendingJobs();
    logger.info(`Processing ${pendingJobs.length} pending jobs`);

    const generator = new ArticleGenerator();
    const evaluator = new ContentEvaluator();
    const interestCalculator = new InterestCalculator();
    const notificationService = new NotificationService();

    const allGeneratedArticles = [];

    for (const job of pendingJobs) {
      const userId = job.metadata?.userId as string;
      if (!userId) continue;

      // 収集データ取得
      const rawData = await cacheStrategy.get(`collection:${job.id}`);
      if (!rawData || !Array.isArray(rawData)) {
        logger.warn(`No data found for job ${job.id}`);
        continue;
      }

      const generatedArticles = [];

      // グループ化して記事生成（類似コンテンツをまとめる）
      const groupedContent = this.groupSimilarContent(rawData);

      for (const group of groupedContent) {
        try {
          // 品質評価
          const qualityScores = await Promise.all(
            group.map(content => evaluator.evaluate(content))
          );
          const avgQuality = qualityScores.reduce((a, b) => a + b, 0) / qualityScores.length;

          if (avgQuality < 5) continue;

          // 興味度計算
          const user = await UserModel.findById(userId);
          if (!user) continue;

          const interestScores = await Promise.all(
            group.map(content =>
              interestCalculator.calculate(content, user.profile as any)
            )
          );
          const avgInterest = interestScores.reduce((a, b) => a + b, 0) / interestScores.length;

          if (avgInterest < 3) continue;

          // 記事生成
          const article = await generator.generate(group, user.profile as any);

          const savedArticle = await ArticleModel.create({
            ...article,
            authorId: userId,
            interestScore: Math.round(avgInterest),
            qualityScore: Math.round(avgQuality)
          });

          generatedArticles.push(savedArticle);

        } catch (error) {
          logger.error('Failed to generate article from group', error as Error);
        }
      }

      // ジョブ完了
      await CollectionJobModel.complete(job.id, {
        articlesCreated: generatedArticles.length
      });

      allGeneratedArticles.push(...generatedArticles);
    }

    // 高品質記事を通知
    const highQualityArticles = allGeneratedArticles.filter(
      article => article.interestScore >= 7
    );

    if (highQualityArticles.length > 0) {
      await notificationService.notifyNewArticles(highQualityArticles);
    }

    logger.info('Generation cron completed', {
      totalGenerated: allGeneratedArticles.length,
      highQuality: highQualityArticles.length
    });

    return NextResponse.json({
      success: true,
      articlesGenerated: allGeneratedArticles.length
    });

  } catch (error) {
    logger.error('Generation cron failed', error as Error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

private groupSimilarContent(items: RawContentData[]): RawContentData[][] {
  // 簡易的なグループ化（実際はより高度なアルゴリズムを使用）
  const groups: RawContentData[][] = [];
  const used = new Set<number>();

  for (let i = 0; i < items.length; i++) {
    if (used.has(i)) continue;

    const group = [items[i]];
    used.add(i);

    // タイトルの類似度でグループ化
    for (let j = i + 1; j < items.length; j++) {
      if (used.has(j)) continue;

      if (this.areSimilar(items[i], items[j])) {
        group.push(items[j]);
        used.add(j);
      }
    }

    groups.push(group);
  }

  return groups;
}

private areSimilar(a: RawContentData, b: RawContentData): boolean {
  // 簡易的な類似度判定（実際はより高度なアルゴリズムを使用）
  const wordsA = new Set(a.title.toLowerCase().split(/\s+/));
  const wordsB = new Set(b.title.toLowerCase().split(/\s+/));

  const intersection = new Set([...wordsA].filter(x => wordsB.has(x)));
  const union = new Set([...wordsA, ...wordsB]);

  const jaccard = intersection.size / union.size;
  return jaccard > 0.3;
}

export const runtime = 'nodejs';
export const maxDuration = 300;
```

## 8. 通知サービス実装

```typescript
// src/lib/notifications/slack.ts
import axios from 'axios';
import type { Article } from '@/lib/types';
import { Logger } from '@/lib/utils/logger';

export class NotificationService {
  private webhookUrl: string;
  private logger: Logger;

  constructor() {
    this.webhookUrl = process.env.SLACK_WEBHOOK_URL!;
    this.logger = new Logger('NotificationService');
  }

  async notifyNewArticles(articles: Article[]): Promise<void> {
    if (!this.webhookUrl) {
      this.logger.warn('Slack webhook URL not configured');
      return;
    }

    try {
      const message = this.buildSlackMessage(articles);

      await axios.post(this.webhookUrl, message);

      this.logger.info('Slack notification sent', {
        articleCount: articles.length,
      });
    } catch (error) {
      this.logger.error('Failed to send Slack notification', error as Error);
    }
  }

  private buildSlackMessage(articles: Article[]) {
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `🤖 新しい記事が${articles.length}件投稿されました！`,
        },
      },
    ];

    articles.forEach((article, index) => {
      blocks.push(
        {
          type: 'divider',
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*${index + 1}. ${article.title}*\n${article.summary}`,
          },
          accessory: {
            type: 'button',
            text: {
              type: 'plain_text',
              text: '記事を読む',
            },
            url: `${process.env.NEXT_PUBLIC_APP_URL}/articles/${article.id}`,
            action_id: `view_article_${article.id}`,
          },
        },
        {
          type: 'context',
          elements: [
            {
              type: 'mrkdwn',
              text: `興味度: ${'⭐'.repeat(Math.min(article.interestScore, 5))}`,
            },
            {
              type: 'mrkdwn',
              text: `カテゴリ: ${article.category?.name || '未分類'}`,
            },
          ],
        }
      );
    });

    return { blocks };
  }

  async notifyError(error: Error, context: Record<string, any>): Promise<void> {
    if (!this.webhookUrl) return;

    try {
      await axios.post(this.webhookUrl, {
        text: `⚠️ エラーが発生しました`,
        blocks: [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `*エラー:* ${error.message}\n*コンテキスト:* \`\`\`${JSON.stringify(context, null, 2)}\`\`\``,
            },
          },
        ],
      });
    } catch (notifyError) {
      this.logger.error('Failed to send error notification', notifyError as Error);
    }
  }
}
```

## 9. デプロイメント設定

### 9.1 Vercel設定

```json
// vercel.json
{
  "framework": "nextjs",
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "regions": ["hnd1"],
  "functions": {
    "src/app/api/internal/collect/route.ts": {
      "maxDuration": 300
    },
    "src/app/api/internal/generate/route.ts": {
      "maxDuration": 300
    },
    "src/app/api/internal/cron/collect/route.ts": {
      "maxDuration": 300
    },
    "src/app/api/internal/cron/generate/route.ts": {
      "maxDuration": 300
    }
  },
  "crons": [
    {
      "path": "/api/internal/cron/collect",
      "schedule": "0 7 * * *"
    },
    {
      "path": "/api/internal/cron/generate",
      "schedule": "30 7 * * *"
    }
  ]
}
```

### 9.2 環境変数

```bash
# .env.example
# Database
DATABASE_URL="postgres://user:password@host:5432/dbname"
DATABASE_URL_NON_POOLING="postgres://user:password@host:5432/dbname"

# Cache
KV_URL="redis://user:password@host:6379"
KV_REST_API_URL="https://..."
KV_REST_API_TOKEN="..."

# AI Services
OPENAI_API_KEY="sk-..."
ANTHROPIC_API_KEY="sk-ant-..."

# External APIs
GOOGLE_CUSTOM_SEARCH_API_KEY="..."
GOOGLE_SEARCH_ENGINE_ID="..."
NEWS_API_KEY="..."
REDDIT_CLIENT_ID="..."
REDDIT_CLIENT_SECRET="..."

# Notifications
SLACK_WEBHOOK_URL="https://hooks.slack.com/services/..."

# Security
INTERNAL_API_KEY="..."
CRON_SECRET="..."

# App
NEXT_PUBLIC_APP_URL="https://your-domain.com"
NODE_ENV="production"
```

## 10. まとめ

この詳細設計書では、個人キュレーションサイトの実装に必要なすべての技術的詳細を網羅しました。

### 主要な設計ポイント

1. **モジュラー設計**: 各機能を独立したサービスとして実装し、保守性と拡張性を確保
2. **型安全性**: TypeScriptとZodを活用した厳密な型定義
3. **パフォーマンス**: 多層キャッシュ戦略とSSG/ISRの活用
4. **エラーハンドリング**: 包括的なエラー処理と通知機能
5. **自動化**: Cron Jobによる完全自動化

### 次のステップ

1. 開発環境のセットアップ
2. データベーススキーマの実装
3. 基本的なCRUD機能の実装
4. AI統合の実装とテスト
5. フロントエンドの実装
6. デプロイと動作確認

この設計に基づいて実装を進めることで、要件を満たす高品質なキュレーションサイトを構築できます。
